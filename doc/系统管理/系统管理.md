基础框架功能搭建

## F1：YApi管理后端系统接口

- 个人空间地址：https://yapi.baidu.com/group/2491
- 添加项目
  - ![image-20201019082912418](系统管理.assets/image-20201019082912418.png)
  - ![image-20201019082941214](系统管理.assets/image-20201019082941214.png)
  - ![image-20201019082951596](系统管理.assets/image-20201019082951596.png)
  - 修改默认生成的公共分类为公共接口
    - ![image-20201019083314017](系统管理.assets/image-20201019083314017.png)
- 添加分类---登录相关接口
  - ![image-20201019083147456](系统管理.assets/image-20201019083147456.png)
- 在登录和退出相关接口分类下添加接口（先创建，详细内容后面完善）
  - ![image-20201019083355614](系统管理.assets/image-20201019083355614.png)
  - ![image-20201019083757457](系统管理.assets/image-20201019083757457.png)
  - ![image-20201019083707081](系统管理.assets/image-20201019083707081.png)
  - ![image-20201019083623665](系统管理.assets/image-20201019083623665.png)
- 完成结果（具体内容后续晚上）
  - ![image-20201019083822639](系统管理.assets/image-20201019083822639.png)

## F2：【公共项目】hospital-commons修改

- ![image-20201020085417746](系统管理.assets/image-20201020085417746.png)

### F2.1：Constants常量类

~~~java
package com.fclever.constants;

/**
 * 系统要使用的常量数据
 * @author Fclever
 * @create 2020-10-19 08:56
 */
public class Constants {

    /**
     * 令牌
     */
    public static final String TOKEN = "token";
    /**
     * 系统用户类型
     */
    public static final String USER_ADMIN = "0";
    public static final String USER_NORMAL = "1";
    /**
     * 返回检验码
     */
    public static final String UNIQUE = "0";
    public static final String NOT_UNIQUE = "1";
    /**
     * 有效状态
     */
    public static final String STATUS_TRUE = "0";
    public static final String STATUS_FALSE = "1";

    /**
     * 删除状态
     */
    public static final String DEL_FALSE = "0";
    public static final String DEL_TRUE = "1";
    /**
     * 菜单类型 M目录 C菜单 F权限
     */
    public static final String MENU_TYPE_M = "M";
    public static final String MENU_TYPE_C = "C";
    public static final String MENU_TYPE_F = "F";
    /**
     * 入库单状态 1未提交2待审核 3审核通过 4审核失败 5作废 6 入库成功
     */
    public static final String STOCK_PURCHASE_STATUS_1 = "1";
    public static final String STOCK_PURCHASE_STATUS_2 = "2";
    public static final String STOCK_PURCHASE_STATUS_3 = "3";
    public static final String STOCK_PURCHASE_STATUS_4 = "4";
    public static final String STOCK_PURCHASE_STATUS_5 = "5";
    public static final String STOCK_PURCHASE_STATUS_6 = "6";
    /**
     * 入库状态 0未入库 1已入库
     */
    public static final String STOCK_STORAGE_0 = "0";
    public static final String STOCK_STORAGE_1 = "1";
    /**
     * 默认预警值
     */
    Long DEFAULT_WARNING = 50L;

    /**
     * 排班状态
     */
    public static final String SCHEDULING_FLAG_TRUE = "0";
    public static final String SCHEDULING_FLAG_FALSE = "1";
    /**
     * 是否完善信息
     */
    public static final String IS_FINAL_FALSE = "0";
    public static final String IS_FINAL_TRUE = "1";
    /**
     * 挂号单状态
     */
    public static final String REG_STATUS_0 = "0"; //待支付
    public static final String REG_STATUS_1 = "1"; //待就诊
    public static final String REG_STATUS_2 = "2"; //就诊中
    public static final String REG_STATUS_3 = "3"; //就诊完成
    public static final String REG_STATUS_4 = "4"; //已退号
    public static final String REG_STATUS_5 = "5"; //已作废
    /**
     * 处方类型
     */
    public static final String CO_TYPE_MEDICINES = "0";
    public static final String CO_TYPE_CHECK = "1";
    /**
     * 支付单状态状态，0未支付,1已支付，2支付超时
     */
    public static final String ORDER_STATUS_0 = "0";
    public static final String ORDER_STATUS_1 = "1";
    public static final String ORDER_STATUS_2 = "2";
    /**
     * 订单子项目支付状态
     * 0未支付，1已支付，2，已退费  3，已完成
     */
    public static final String ORDER_DETAILS_STATUS_0 = "0";
    public static final String ORDER_DETAILS_STATUS_1 = "1";
    public static final String ORDER_DETAILS_STATUS_2 = "2";
    public static final String ORDER_DETAILS_STATUS_3 = "3";
    /**
     * 检查状态  0 检查中   1检查完成
     */
    public static final String RESULT_STATUS_0 = "0";
    public static final String RESULT_STATUS_1 = "1";

    /**
     * 退费单状态，订单状态0未退费  1 退费成功 2退费失败
     */
    public static final String ORDER_BACKFEE_STATUS_0 = "0";
    public static final String ORDER_BACKFEE_STATUS_1 = "1";
    public static final String ORDER_BACKFEE_STATUS_2 = "2";
    /**
     * 支付类型
     */
    public static final String PAY_TYPE_0 = "0";//现金
    public static final String PAY_TYPE_1 = "1";//支付宝

    /**
     * redis的字典前缀
     */
    public static final String DICT_REDIS_PROFIX="dict:";

    /**
     * 登陆状态  0 成功  1失败
     */
    public static final String LOGIN_SUCCESS = "0";
    public static final String LOGIN_ERROR = "1";
    /**
     * 登陆类型0系统用户1患者用户
     */
    public static final String LOGIN_TYPE_SYSTEM = "0" ;
    public static final String LOGIN_TYPE_PATIENT = "1" ;
}

~~~



### F2.2：HttpStatus常量类

~~~java
package com.fclever.constants;

/**
 * 响应状态码
 * @author Fclever
 * @create 2020-10-19 13:22
 */
public class HttpStatus {

    /**
     * 操作成功
     */
    public static final int SUCCESS = 200;

    /**
     * 参数列表错误（缺少，格式不匹配）
     */
    public static final int BAD_REQUEST = 400;

    /**
     * 未授权
     */
    public static final int UNAUTHORIZED = 401;

    /**
     * 访问受限，授权过期
     */
    public static final int FORBIDDEN = 403;

    /**
     * 资源，服务未找到
     */
    public static final int NOT_FOUND = 404;

    /**
     * 不允许的http方法
     */
    public static final int BAD_METHOD = 405;

    /**
     * 系统内部错误
     */
    public static final int ERROR = 500;
}

~~~



### F2.3：BaseEntity实体基础父类

~~~java
package com.fclever.domain;

import java.io.Serializable;

/**
 * 基础父类
 *      后续各个模块中生成的实体类都需要继承该类
 *      因为做远程调用的类必须要进行序列化，这里统一做序列化处理
 *      然后新的实体类只需要统一继承该类即可
 * @author Fclever
 * @create 2020-10-19 13:48
 */
public class BaseEntity implements Serializable {
    private static final long serialVersionUID=1L;
}

~~~



### F2.4：SimpleUser类

~~~java
package com.fclever.domain;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 远程调用其他服务时，需要传递当前登录用户一些必要信息时，可以传递该对象
 *
 * @author Fclever
 * @create 2020-10-19 13:50
 */
@Data // 自动生成setter|getter等方法
@AllArgsConstructor // 生成全部参数的构造方法
@NoArgsConstructor // 生成无参构造
public class SimpleUser implements Serializable {
    private Serializable userId;
    private String userName;
}

~~~



### F2.5：AjaxResult通用返回对象类

~~~java
package com.fclever.vo;

import com.fclever.constants.HttpStatus;

import java.util.HashMap;

/**
 * 后端返回数据的形式（状态码+消息+内容+数据条数）
 * @author Fclever
 * @create 2020-10-19 19:40
 */
public class AjaxResult extends HashMap<String,Object> {

    private static final long serialVersionUID = 1L;

    /**
     * 状态码
     */
    public static final String CODE_TAG = "code";

    /**
     * 返回消息
     */
    public static final String MSG_TAG = "msg";

    /**
     * 数据对象
     */
    public static final String DATA_TAG = "data";

    /**
     * 数据总条数
     */
    public static final String DATA_TOTAL = "total";

    /**
     * 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。
     */
    public AjaxResult() {
    }

    /**
     * 初始化一个新创建的 AjaxResult 对象
     *
     * @param code 状态码
     * @param msg  返回内容
     */
    public AjaxResult(int code, String msg) {
        super.put(CODE_TAG, code);
        super.put(MSG_TAG, msg);
    }

    /**
     * 初始化一个新创建的 AjaxResult 对象
     *
     * @param code 状态码
     * @param msg  返回内容
     * @param data 数据对象
     */
    public AjaxResult(int code, String msg, Object data) {
        super.put(CODE_TAG, code);
        super.put(MSG_TAG, msg);
        super.put(DATA_TAG, data);
    }

    /**
     * 初始化一个新创建的 AjaxResult 对象
     *
     * @param code  状态码
     * @param msg   返回内容
     * @param data  数据对象
     * @param total 数据总条数
     */
    public AjaxResult(int code, String msg, Object data, Long total) {
        super.put(CODE_TAG, code);
        super.put(MSG_TAG, msg);
        super.put(DATA_TAG, data);
        super.put(DATA_TOTAL, total);
    }

    /**
     * 返回成功消息---最终返回{HttpStatus.SUCCESS，“操作成功”，null，“”}
     *
     * @return 成功消息
     */
    public static AjaxResult success() {
        return AjaxResult.success("操作成功");
    }

    /**
     * 返回成功消息--可以自定义消息内容，最终返回{HttpStatus.SUCCESS，自定义消息，null，“”}
     *
     * @param msg 返回内容
     * @return 成功消息
     */
    public static AjaxResult success(String msg) {
        return AjaxResult.success(msg, null);
    }

    /**
     * 返回成功数据--可以自定义数据对象，最终返回{HttpStatus.SUCCESS，“操作成功”，自定义数据对象，“”}
     *
     * @param data 数据条数
     * @return 成功消息
     */
    public static AjaxResult success(Object data) {
        return AjaxResult.success("操作成功", data);
    }

    /**
     * 返回成功消息--可以自定义消息内容和数据对象，最终返回{HttpStatus.SUCCESS，自定义消息，自定义数据对象，“”}
     *
     * @param msg  返回内容
     * @param data 数据对象
     * @return 成功消息
     */
    public static AjaxResult success(String msg, Object data) {
        return new AjaxResult(HttpStatus.SUCCESS, msg, data);
    }

    /**
     * 返回成功消息--可以自定义消息内容，数据对象和数据条数，最终返回{HttpStatus.SUCCESS，自定义消息，自定义数据对象，数据条数}
     *
     * @param msg  返回内容
     * @param data 数据对象
     * @param total 数据对象条数
     * @return 成功消息
     */
    public static AjaxResult success(String msg, Object data,Long total) {
        return new AjaxResult(HttpStatus.SUCCESS, msg, data,total);
    }

    /**
     * 返回失败消息--最终返回{HttpStatus.BAD_REQUEST，“操作成功”，null，“”}
     */
    public static AjaxResult fail() {
        return AjaxResult.fail("操作失败");
    }

    /**
     * 返回失败消息--可以自定义消息内容，最终返回{HttpStatus.BAD_REQUEST，自定义消息，null，“”}
     *
     * @param msg 返回内容
     * @return 警告消息
     */
    public static AjaxResult fail(String msg) {
        return AjaxResult.fail(msg, null);
    }

    /**
     * 返回失败消息--可以自定义消息内容和数据对象，最终返回{HttpStatus.BAD_REQUEST，自定义消息，自定义数据对象，“”}
     *
     * @param msg  返回内容
     * @param data 数据对象
     * @return 警告消息
     */
    public static AjaxResult fail(String msg, Object data) {
        return new AjaxResult(HttpStatus.BAD_REQUEST, msg, data);
    }

    /**
     * 返回错误消息--最终返回{HttpStatus.ERROR，“操作失败”，null，“”}
     */
    public static AjaxResult error() {
        return AjaxResult.error("操作失败");
    }

    /**
     * 返回错误消息--可以自定义消息内容，最终返回{HttpStatus.ERROR，自定义消息，null，“”}
     *
     * @param msg 返回内容
     * @return 警告消息
     */
    public static AjaxResult error(String msg) {
        return AjaxResult.error(msg, null);
    }

    /**
     * 返回错误消息--可以自定义消息内容和数据对象，最终返回{HttpStatus.ERROR，自定义消息，自定义数据对象，“”}
     *
     * @param msg  返回内容
     * @param data 数据对象
     * @return 警告消息
     */
    public static AjaxResult error(String msg, Object data) {
        return new AjaxResult(HttpStatus.ERROR, msg, data);
    }

    /**
     * 返回错误消息--可以自定义状态码和消息内容，最终返回{自定义状态码，自定义消息，null，“”}
     *
     * @param code 状态码
     * @param msg  返回内容
     * @return 警告消息
     */
    public static AjaxResult error(int code, String msg) {
        return new AjaxResult(code, msg, null);
    }

    /**
     * 返回错误消息
     *
     * @param rows 状态码
     * @return 添加修改删除转化信息
     */
    public static AjaxResult toAjax(int rows) {
        return rows > 0 ? AjaxResult.success() : AjaxResult.fail();
    }

}

~~~



### F2.6：MenuTreeVolume类

~~~java
package com.fclever.vo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 构造菜单并返回给前端
 * @author Fclever
 * @create 2020-10-20 08:01
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class MenuTreeVo {

    // 菜单id
    private String id;

    // 菜单对应的url
    private String serPath;

    // 是否显示该菜单
    private boolean show = true;

    public MenuTreeVo(String id, String serPath) {
        this.id = id;
        this.serPath = serPath;
    }
}

~~~



### F2.7：BaseDto类

~~~java
package com.fclever.dto;

import com.fclever.domain.SimpleUser;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;

import java.io.Serializable;
import java.util.Date;

/**
 * 基础数据传输类，封装前端传递过来的一些参数
 * @author Fclever
 * @create 2020-10-20 08:10
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class BaseDto implements Serializable {
    /**
     * 页码 默认1
     */
    private Integer pageNum = 1;

    /**
     * 每页显示条数 默认10
     */
    private Integer pageSize = 10;

    /**
     * 当前操作对象
     */
    private SimpleUser simpleUser;

    /**
     * 开始时间
     */
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date beginTime;
    /**
     * 结束时间
     */
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date endTime;

}

~~~



### F2.8：LoginBodyDto类

~~~java
package com.fclever.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 基础登录信息封装，保留前端登录时的一些信息，并可以做后盾数据校验
 * @author Fclever
 * @create 2020-10-20 08:12
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class LoginBodyDto implements Serializable {
    //  用户名
    private String username;
    //  密码
    private String password;
    // 验证码
    private String captcha;
}

~~~



### F2.9：HttpUtils工具类

~~~java
package com.fclever.utils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.*;
import java.io.*;
import java.net.ConnectException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.security.cert.X509Certificate;

/**
 * 用来发送Http请求，一般用在记录系统操作日志或者登录日志
 *
 * @author Fclever
 * @create 2020-10-20 08:17
 */
public class HttpUtils {

    private static final Logger log = LoggerFactory.getLogger(HttpUtils.class);
    /**
     * 向指定 URL 发送GET方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @return 所代表远程资源的响应结果
     */
    public static String sendGet(String url, String param)
    {
        StringBuilder result = new StringBuilder();
        BufferedReader in = null;
        try
        {
            String urlNameString = url + "?" + param;
            log.info("sendGet - {}", urlNameString);
            URLConnection connection = getUrlConnection(urlNameString);
            connection.connect();
            in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String line;
            while ((line = in.readLine()) != null)
            {
                result.append(line);
            }
            log.info("recv - {}", result);
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendGet ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendGet SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendGet IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendGet Exception, url=" + url + ",param=" + param, e);
        }
        finally
        {
            try
            {
                if (in != null)
                {
                    in.close();
                }
            }
            catch (Exception ex)
            {
                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);
            }
        }
        return result.toString();
    }

    /**
     * 向指定 URL 发送POST方法的请求
     *
     * @param url 发送请求的 URL
     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。
     * @return 所代表远程资源的响应结果
     */
    public static String sendPost(String url, String param)
    {
        PrintWriter out = null;
        BufferedReader in = null;
        StringBuilder result = new StringBuilder();
        try
        {
            String urlNameString = url + "?" + param;
            log.info("sendPost - {}", urlNameString);
            URLConnection conn = getUrlConnection(urlNameString);
            conn.setRequestProperty("Accept-Charset", "utf-8");
            conn.setRequestProperty("contentType", "utf-8");
            conn.setDoOutput(true);
            conn.setDoInput(true);
            out = new PrintWriter(conn.getOutputStream());
            out.print(param);
            out.flush();
            in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "utf-8"));
            String line;
            while ((line = in.readLine()) != null)
            {
                result.append(line);
            }
            log.info("recv - {}", result);
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendPost ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendPost SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendPost IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendPost Exception, url=" + url + ",param=" + param, e);
        }
        finally
        {
            try
            {
                if (out != null)
                {
                    out.close();
                }
                if (in != null)
                {
                    in.close();
                }
            }
            catch (IOException ex)
            {
                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);
            }
        }
        return result.toString();
    }

    private static URLConnection getUrlConnection(String urlNameString) throws IOException {
        URL realUrl = new URL(urlNameString);
        URLConnection conn = realUrl.openConnection();
        conn.setRequestProperty("accept", "*/*");
        conn.setRequestProperty("connection", "Keep-Alive");
        conn.setRequestProperty("user-agent",
                "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
        return conn;
    }

    public static String sendSSLPost(String url, String param)
    {
        StringBuilder result = new StringBuilder();
        String urlNameString = url + "?" + param;
        try
        {
            log.info("sendSSLPost - {}", urlNameString);
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, new TrustManager[] { new TrustAnyTrustManager() }, new java.security.SecureRandom());
            URL console = new URL(urlNameString);
            HttpsURLConnection conn = (HttpsURLConnection) console.openConnection();
            conn.setRequestProperty("accept", "*/*");
            conn.setRequestProperty("connection", "Keep-Alive");
            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            conn.setRequestProperty("Accept-Charset", "utf-8");
            conn.setRequestProperty("contentType", "utf-8");
            conn.setDoOutput(true);
            conn.setDoInput(true);

            conn.setSSLSocketFactory(sc.getSocketFactory());
            conn.setHostnameVerifier(new TrustAnyHostnameVerifier());
            conn.connect();
            InputStream is = conn.getInputStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            String ret = "";
            while ((ret = br.readLine()) != null)
            {
                if (ret != null && !ret.trim().equals(""))
                {
                    result.append(new String(ret.getBytes("ISO-8859-1"), "utf-8"));
                }
            }
            log.info("recv - {}", result);
            conn.disconnect();
            br.close();
        }
        catch (ConnectException e)
        {
            log.error("调用HttpUtils.sendSSLPost ConnectException, url=" + url + ",param=" + param, e);
        }
        catch (SocketTimeoutException e)
        {
            log.error("调用HttpUtils.sendSSLPost SocketTimeoutException, url=" + url + ",param=" + param, e);
        }
        catch (IOException e)
        {
            log.error("调用HttpUtils.sendSSLPost IOException, url=" + url + ",param=" + param, e);
        }
        catch (Exception e)
        {
            log.error("调用HttpsUtil.sendSSLPost Exception, url=" + url + ",param=" + param, e);
        }
        return result.toString();
    }

    private static class TrustAnyTrustManager implements X509TrustManager
    {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType)
        {
        }

        @Override
        public X509Certificate[] getAcceptedIssuers()
        {
            return new X509Certificate[] {};
        }
    }

    private static class TrustAnyHostnameVerifier implements HostnameVerifier
    {
        @Override
        public boolean verify(String hostname, SSLSession session)
        {
            return true;
        }
    }
}
~~~



### F2.10：IpUtils IP地址获取类

~~~java
package com.fclever.utils;

import javax.servlet.http.HttpServletRequest;
import java.net.InetAddress;
import java.net.UnknownHostException;

/**
 * 查询IP信息
 *             单纯在网络请求中可以获取到IP地址，但是对于登录地址等信息就没法默认获取了
 *  *          因此使用这些工具类来获取
 * @author Fclever
 * @create 2020-10-20 08:22
 */
public class IpUtils {

    /**
     * 得到当前请求的IP
     * @param request
     * @return
     */
    public static String getIpAddr(HttpServletRequest request)
    {
        if (request == null)
        {
            return "unknown";
        }
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("X-Forwarded-For");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getHeader("X-Real-IP");
        }

        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip))
        {
            ip = request.getRemoteAddr();
        }

        return "0:0:0:0:0:0:0:1".equals(ip) ? "127.0.0.1" : ip;
    }

    public static boolean internalIp(String ip)
    {
        byte[] addr = textToNumericFormatV4(ip);
        return internalIp(addr) || "127.0.0.1".equals(ip);
    }

    private static boolean internalIp(byte[] addr)
    {
        if (null!=addr || addr.length < 2)
        {
            return true;
        }
        final byte b0 = addr[0];
        final byte b1 = addr[1];
        // 10.x.x.x/8
        final byte SECTION_1 = 0x0A;
        // 172.16.x.x/12
        final byte SECTION_2 = (byte) 0xAC;
        final byte SECTION_3 = (byte) 0x10;
        final byte SECTION_4 = (byte) 0x1F;
        // 192.168.x.x/16
        final byte SECTION_5 = (byte) 0xC0;
        final byte SECTION_6 = (byte) 0xA8;
        switch (b0)
        {
            case SECTION_1:
                return true;
            case SECTION_2:
                if (b1 >= SECTION_3 && b1 <= SECTION_4)
                {
                    return true;
                }
            case SECTION_5:
                switch (b1)
                {
                    case SECTION_6:
                        return true;
                }
            default:
                return false;
        }
    }

    /**
     * 将IPv4地址转换成字节
     *
     * @param text IPv4地址
     * @return byte 字节
     */
    public static byte[] textToNumericFormatV4(String text)
    {
        if (text.length() == 0)
        {
            return null;
        }

        byte[] bytes = new byte[4];
        String[] elements = text.split("\\.", -1);
        try
        {
            long l;
            int i;
            switch (elements.length)
            {
                case 1:
                    l = Long.parseLong(elements[0]);
                    if ((l < 0L) || (l > 4294967295L))
                        return null;
                    bytes[0] = (byte) (int) (l >> 24 & 0xFF);
                    bytes[1] = (byte) (int) ((l & 0xFFFFFF) >> 16 & 0xFF);
                    bytes[2] = (byte) (int) ((l & 0xFFFF) >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 2:
                    l = Integer.parseInt(elements[0]);
                    if ((l < 0L) || (l > 255L))
                        return null;
                    bytes[0] = (byte) (int) (l & 0xFF);
                    l = Integer.parseInt(elements[1]);
                    if ((l < 0L) || (l > 16777215L))
                        return null;
                    bytes[1] = (byte) (int) (l >> 16 & 0xFF);
                    bytes[2] = (byte) (int) ((l & 0xFFFF) >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 3:
                    for (i = 0; i < 2; ++i)
                    {
                        l = Integer.parseInt(elements[i]);
                        if ((l < 0L) || (l > 255L))
                            return null;
                        bytes[i] = (byte) (int) (l & 0xFF);
                    }
                    l = Integer.parseInt(elements[2]);
                    if ((l < 0L) || (l > 65535L))
                        return null;
                    bytes[2] = (byte) (int) (l >> 8 & 0xFF);
                    bytes[3] = (byte) (int) (l & 0xFF);
                    break;
                case 4:
                    for (i = 0; i < 4; ++i)
                    {
                        l = Integer.parseInt(elements[i]);
                        if ((l < 0L) || (l > 255L))
                            return null;
                        bytes[i] = (byte) (int) (l & 0xFF);
                    }
                    break;
                default:
                    return null;
            }
        }
        catch (NumberFormatException e)
        {
            return null;
        }
        return bytes;
    }

    public static String getHostIp()
    {
        try
        {
            return InetAddress.getLocalHost().getHostAddress();
        }
        catch (UnknownHostException e)
        {
        }
        return "127.0.0.1";
    }

    public static String getHostName()
    {
        try
        {
            return InetAddress.getLocalHost().getHostName();
        }
        catch (UnknownHostException e)
        {
        }
        return "未知";
    }
}

~~~



### F2.11：AddressUtils地址查询工具类

~~~java
package com.fclever.utils;

import com.alibaba.fastjson.JSONObject;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 根据IP地址查询真实地址的工具类
 * @author Fclever
 * @create 2020-10-20 08:27
 */
public class AddressUtils {

    private static final Logger log = LoggerFactory.getLogger(AddressUtils.class);

    // 淘宝服务查询得劲接口
    public static final String IP_URL = "http://ip.taobao.com/service/getIpInfo.php";

    public static String getRealAddressByIP(String ip) {
        String address = "XX XX";
        // 内网不查询
        if (IpUtils.internalIp(ip)) {
            return "内网IP";
        }

        String rspStr = HttpUtils.sendPost(IP_URL, "ip=" + ip);
        if (StringUtils.isEmpty(rspStr)) {
            log.error("获取地理位置异常 {}", ip);
            return address;
        }
        // 转换为json对象
        JSONObject obj = JSONObject.parseObject(rspStr);
        // 获取数据
        JSONObject data = obj.getObject("data", JSONObject.class);
        // 区域
        String region = data.getString("region");
        // 城市
        String city = data.getString("city");
        address = region + " " + city;
        return address;
    }

}

~~~



### F2.12：IdGeneratorSnowflake雪花算法工具类

~~~java
package com.fclever.utils;

import cn.hutool.core.lang.Snowflake;
import cn.hutool.core.net.NetUtil;
import cn.hutool.core.util.IdUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 分布式自增ID生成算法
 *             所有生成的id按时间递增
 *             整个分布式系统内不会产生重复id
 * @author Fclever
 * @create 2020-10-20 08:25
 */
public class IdGeneratorSnowflake {

    private static final Logger log = LoggerFactory.getLogger(HttpUtils.class);
    private static long workId = 0;
    private static long datacenterId = 1;
    private static Snowflake snowflake;


    static {
        try {
            workId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr());
            log.info("当前机器的工作ID为:" + workId);
            snowflake=IdUtil.createSnowflake(workId, datacenterId);
        } catch (Exception e) {
            e.printStackTrace();
            log.error("当前机器的workId获取失败", e);
            workId = NetUtil.getLocalhostStr().hashCode();
        }
    }

    /**
     * 生成ID
     */
    public static synchronized Long snowflakeId() {
        return snowflake.nextId();
    }

    /**
     * 根据前缀前成ID
     */
    public static String generatorIdWithProfix(String profix) {
        return profix + snowflakeId();
    }
}

~~~



## F3：【系统模块】system-web修改

- 添加MyBatis-plus分页插件

  ~~~java
  package com.fclever.config.mybatisplus;
  
  
  import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;
  import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  import org.springframework.transaction.annotation.EnableTransactionManagement;
  
  /**
   * MybatisPlus分页插件
   *          官网对应位置：https://baomidou.com/guide/page.html
   * @author Fclever
   * @create 2020-10-20 09:00
   */
  @EnableTransactionManagement
  @Configuration
  public class MybatisPlusConfig {
  
      @Bean
      public PaginationInterceptor paginationInterceptor() {
          PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
          // paginationInterceptor.setOverflow(false);
          // 设置最大单页限制数量，默认 500 条，-1 不受限制
          // paginationInterceptor.setLimit(500);
          // 开启 count 的 join 优化,只针对部分 left join
          paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));
          return paginationInterceptor;
      }
  }
  
  ~~~

  

# 登录功能system-web

## 后端

### F1：安装逆向工程插件

- 下载

  - 地址：https://zhile.io/2019/04/23/mybatis-code-helper-pro-crack.html

  - 根据自己的IDEA版本来选择，框中为19和20版本

    - ![image-20201020122951375](系统管理.assets/image-20201020122951375.png)

  - sha1sum:（这里没有做校验）

    ~~~xml
    MybatisCodeHelperNew-2.8.2-183-201
    sha1sum: 0dccbc14b5494b4a7b85f38b82cf5b6a7c544354
    MybatisCodeHelperNew-2.8.1-191-201
    sha1sum: b2c9f88ae3caf09382c7f00907bc132e5151002b
    ~~~

    

- 本地安装

  - ![image-20201020114446369](系统管理.assets/image-20201020114446369.png)

- 重启IDEA

### F2：使用IDEA连接数据库

- 使用IDEA连接数据库
  - ![image-20201020123713212](系统管理.assets/image-20201020123713212.png)
  - ![image-20201020124817822](系统管理.assets/image-20201020124817822.png)
  - ![image-20201020125415387](系统管理.assets/image-20201020125415387.png)

### F3：生成User表相关并修改（sys_user)

- 操作
  - ![image-20201020125810930](系统管理.assets/image-20201020125810930.png)
  - 发现需要激活。。。
  - ![image-20201020125929225](系统管理.assets/image-20201020125929225.png)
  - 移除表名前缀
    - ![image-20201020130754822](系统管理.assets/image-20201020130754822.png)
    - ![image-20201020130828768](系统管理.assets/image-20201020130828768.png)
  - ![image-20201020131041136](系统管理.assets/image-20201020131041136.png)
  - ![image-20201020131202933](系统管理.assets/image-20201020131202933.png)
  - ![image-20201020131210205](系统管理.assets/image-20201020131210205.png)
  - ![image-20201020131228519](系统管理.assets/image-20201020131228519.png)
  
- 此时可以看到对应文件已经生成，但是发现User类继承的BaseEntity报错了，原因不是很清楚，就是即便设置了hospital-system依赖了hospital-commos，但是hospital-commons中的BaseEntity类并没有在hospital-system中成功引入
  - 打开Projects Structure，可以看到hospit-commons:1.0在报错，其他模块依赖commons也都报错了，其实是找不到对应jar包
    - ![image-20201020144230413](系统管理.assets/image-20201020144230413.png)
  - 双击上框依赖，可以发现依赖的jar包位于本地仓库，但是查阅本地仓库后可以==看到jar包不存在==，因此需要==将hospital-commons进行install==，然后在Project Structure中对相应依赖双击后重新指定路径即可
    - ![image-20201020152320693](系统管理.assets/image-20201020152320693.png)
  - 其他依赖产生的错误同理（或者在文件import中 alt+/出错的包，引入也可以）
  - ！！！或者更简单粗暴，把本地仓库内容删掉，通过IDEAMaven工具重新import（这里想到其实不同项目可以配置不同路径Maven本地仓库，修改下配置文件就行了，重新导入后打开Project Structure删除下报错依赖就可以了）
  - 或者Project Structure中把对应模块所依赖的模块添加（==缺啥加啥==）
    - ![image-20201021124959184](系统管理.assets/image-20201021124959184.png)
  
- 修改UserService  添加登录用到的接口

  ~~~java
  package com.fclever.service;
  
  import com.fclever.domain.User;
  import com.baomidou.mybatisplus.extension.service.IService;
  /**
  @author Fclever
  @create 2020-10-20 13:13
  */
  public interface UserService{
  
      /**
       * 根据手机号查询用户
       *      用户登录是通过手机号和密码
       *      shiro验证：先通过手机号判断用户是否存在，如果存在则继续判断密码正确与否
       * @param phone
       * @return
       */
      User queryUserByPhone(String phone);
  
      /**
       * 根据用户id查询用户
       *      登录之后需要获取用户相关信息，基于token，也就需要用id来查询
       * @param userId
       * @return
       */
      User getOne(Long userId);
  }
  
  ~~~

  

- 修改UserServiceImpl 添加登录用到的接口

  ~~~java
  package com.fclever.service.impl;
  
  import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
  import com.fclever.mapper.UserMapper;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Service;
  import com.fclever.domain.User;
  import com.fclever.service.UserService;
  /**
  @author Fclever
  @create 2020-10-20 13:13
  */
  @Service
  public class UserServiceImpl implements UserService{
  
      @Autowired
      private UserMapper userMapper;
  
      /**
       * 根据手机号查询用户
       *      用户登录是通过手机号和密码
       *      shiro验证：先通过手机号判断用户是否存在，如果存在则继续判断密码正确与否
       * @param phone
       * @return
       */
      @Override
      public User queryUserByPhone(String phone) {
          QueryWrapper<User> qw = new QueryWrapper<>();
          qw.eq(User.COL_PHONE, phone);
          User user = this.userMapper.selectOne(qw);
          return user;
      }
  
      /**
       * 根据用户id查询用户
       *      登录之后需要获取用户相关信息，基于token，也就需要用id来查询
       * @param userId
       * @return
       */
      @Override
      public User getOne(Long userId) {
          return this.userMapper.selectById(userId);
      }
  }
  
  ~~~

  

### F4：生成Menu表相关并修改(sys_menu)

- 操作

  - ![image-20201021084701223](系统管理.assets/image-20201021084701223.png)

  - 移除前缀

    - ![image-20201021090142127](系统管理.assets/image-20201021090142127.png)
    - 这个生成器会记录上一次的操作
    - ![image-20201021090319722](系统管理.assets/image-20201021090319722.png)
    - ![image-20201021090326781](系统管理.assets/image-20201021090326781.png)
    - ![image-20201021090333652](系统管理.assets/image-20201021090333652.png)
    - ![image-20201021090344371](系统管理.assets/image-20201021090344371.png)
    - 生成代码后，修改MenuService和MenuService，提供获取系统菜单的方法

  - MenuService

    ~~~java
    package com.fclever.service;
    
    import com.fclever.domain.Menu;
    import com.baomidou.mybatisplus.extension.service.IService;
    import com.fclever.domain.SimpleUser;
    
    import java.util.List;
    
    /**
    @author Fclever
    @create 2020-10-21 09:04
    */
    public interface MenuService{
    
        /**
         * 查询菜单信息
         *  sys_user表中user_type=0 超级管理员  user_type=1普通用户
         * 如查用户是超级管理员，那么查询所有菜单和权限
         * 如果用户是普通用户，那么根据用户ID关联角色和权限
         * @param isAdmin 是否是超级管理员
         * @param  simpleUser  如果isAdmin=true  simpleUser可以为空
         */
        public List<Menu> selectMenuTree(boolean isAdmin, SimpleUser simpleUser);
    }
    
    ~~~

    

  - MenuServiceImpl

    ~~~java
    package com.fclever.service.impl;
    
    import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
    import com.fclever.constants.Constants;
    import com.fclever.domain.SimpleUser;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import javax.annotation.Resource;
    import java.util.List;
    import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
    import com.fclever.domain.Menu;
    import com.fclever.mapper.MenuMapper;
    import com.fclever.service.MenuService;
    /**
    @author Fclever
    @create 2020-10-21 09:04
    */
    @Service
    public class MenuServiceImpl implements MenuService{
    
        @Autowired
        private MenuMapper menuMapper;
    
        /**
         * 查询菜单信息
         *  超级管理员则查询所有
         *  如果是普通用户，则根据用户id查询对应菜单和权限
         * @param isAdmin 是否是超级管理员
         * @param  simpleUser  如果isAdmin=true  simpleUser可以为空
         * @return
         */
        @Override
        public List<Menu> selectMenuTree(boolean isAdmin, SimpleUser simpleUser) {
            QueryWrapper<Menu> qw=new QueryWrapper<>();
            // 菜单状态为正常（非停用）
            qw.eq(Menu.COL_STATUS, Constants.STATUS_TRUE);
            // 菜单类型为  一级菜单和二级菜单
            qw.in(Menu.COL_MENU_TYPE,Constants.MENU_TYPE_M,Constants.MENU_TYPE_C);
            // 根据父级菜单的id倒序排序
            qw.orderByAsc(Menu.COL_PARENT_ID);
            if(isAdmin){
                return menuMapper.selectList(qw);
            }else{
                //根据用户id查询用户拥有的菜单信息
                return menuMapper.selectList(qw);
            }
        }
    }
    
    ~~~

    

### F5：shiro配置

- 前后端分离Session共享问题
  - 分布式项目为了负载均衡，一般将提供服务的项目启动多个，以登录来说，可能是A机器处理了登录请求，并将登录信息保存到了session中，那么接着登录可能用到了B机器处理了登录请求，那么就不需要再次进行登录验证了，将登录信息在多台机器之间进行共享，集中存储到Redis中，统一管理
  - 用户一开始登录时，并没有token，登录成功后后端会返回一个token，并将此token保存到redis中管理，后面用户再次访问时携带之前的token进行验证，如果后端能从redis中查到就说明认证未失效，可以正常访问，否则就需要重新登录
  - 文章：https://www.cnblogs.com/lzghyh/p/13336620.html
  - ![image-20201021134839848](系统管理.assets/image-20201021134839848.png)
  - ![image-20201021134856670](系统管理.assets/image-20201021134856670.png)

#### F5.1：创建ShiroLoginFilter

~~~java
package com.fclever.config.shiro;

import com.alibaba.fastjson.JSON;
import com.fclever.constants.HttpStatus;
import com.fclever.vo.AjaxResult;
import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletResponse;

/**
 * 登录过滤器
 *      判断用户是否登录
 * @author Fclever
 * @create 2020-10-21 13:50
 */
public class ShiroLoginFilter extends FormAuthenticationFilter {

    /**
     * 在访问controller前进行判断是否登录，返回json，不进行重定向
     *          后端不关心页面的跳转，只负责数据的交互
     * @param request
     * @param response
     * @return true--继续往下执行，false--
     * @throws Exception
     */
    @Override
    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {
        // 获取HttpServletRequest对象
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;
        // 设置响应字符编码UTF-8
        httpServletResponse.setCharacterEncoding("UTF-8");
        // 响应数据类型json
        httpServletResponse.setContentType("application/json");
        // 规范统一响应数据内容
        AjaxResult ajaxResult = AjaxResult.fail();
        // 状态码：未授权
        ajaxResult.put("code", HttpStatus.UNAUTHORIZED);
        // 返回消息
        ajaxResult.put("msg", "登录认证失效，请重新登录！");
        // 输出
        httpServletResponse.getWriter().write(JSON.toJSON(ajaxResult).toString());
        return false;
    }
}

~~~



#### F5.2：创建TokenWebSessionManager

~~~java
package com.fclever.config.shiro;

import com.fclever.constants.Constants;
import org.apache.shiro.util.StringUtils;
import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
import org.apache.shiro.web.util.WebUtils;
import org.springframework.context.annotation.Configuration;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import java.io.Serializable;
import java.util.UUID;

/**
 * Token生成管理
 *      如果有token，从请求头中取出后直接返回前台
 *      如果没有就生成一个
 * @author Fclever
 * @create 2020-10-22 07:58
 */
@Configuration
public class TokenWebSessionManager extends DefaultWebSessionManager {

    /**
     * 获取请求头中保存的token，如果存在则返回，不存在则生成
     * @param request
     * @param response
     * @return
     */
    @Override
    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {
        //从请求头里面得到请求携带的TOKEN 如果不存在就生成一个
        String token= WebUtils.toHttp(request).getHeader(Constants.TOKEN);
        // 如果token为null、“”、“ ” 返回false，否则返回true
        if(StringUtils.hasText(token)){
            return token;
        }else{
            // 使用UIID生成一个数
            return UUID.randomUUID().toString();
        }
    }
}
~~~



#### F5.3：创建ActiverUser

~~~java
package com.fclever.vo;

import com.fclever.domain.User;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * @author Fclever
 * @create 2020-10-22 08:44
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ActiverUser implements Serializable {

    private User user;

    private List<String> roles = Collections.EMPTY_LIST; // 用户所拥有的角色，默认为空

    private List<String> permissions = Collections.EMPTY_LIST; // 用户所拥有的权限，默认为空
}

~~~



#### F5.4：创建UserRealm

~~~java
package com.fclever.config.shiro;

import com.fclever.domain.User;
import com.fclever.service.UserService;
import com.fclever.vo.ActiverUser;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.util.ByteSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;

/**
 * 认证和授权
 *          自定义Realm去匹配用户名和密码
 * @author Fclever
 * @create 2020-10-22 08:21
 */
public class UserRealm extends AuthorizingRealm {

    @Autowired
    @Lazy // 懒加载，使用到该实例的时候再去初始化
    private UserService userService;

    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }

    /**
     * 做认证---登录操作
     * @param token
     * @return
     * @throws AuthenticationException
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // 获取用户登录名   getPrincipal输入的用户名    getCredentials输入的密码
        String phone = token.getPrincipal().toString();
        // 根据电话查询用户是否存在
        User user = userService.queryUserByPhone(phone);
        if (null != user){ // 用户名验证正确，继续验证密码
            // 组装存放到redis中的对象ActiverUser
            /**
             * 从上面流程来看，对登录名做了验证，但是并没有获取输入的密码，然后对密码进行校验
             *      上面只是通过输入用户名从数据库中查询到了该条用户信息（包括密码，盐值）
             *      继承关系：shiroRealm----->AuthorizingRealm---->AuthenticatingRealm
             *      构建SimpleAuthenticationInfo的时候
             *      当执行"return info"之后，会调用AuthenticatingRealm的getAuthenticationInfo()方法
             *      在该方法中，调用了assertCredentialsMatch(token, info);这里面就会对token中保存的输入密码进行盐值加密，然后与数据库中密码进行匹配
             */
            ActiverUser activerUser = new ActiverUser();
            activerUser.setUser(user);
            SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(
                    activerUser, user.getPassword(), ByteSource.Util.bytes(user.getSalt()), this.getName()
            );
            return info;
        }
        // 用户不存在返回null
        return null;
    }

    /**
     * 做授权---判断登录用户是否拥有对菜单或者按钮的操作权限
     * @param principals
     * @return
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        // 该方法得到的对象就是doGetAuthenticationInfo方法返回的SimpleAuthenticationInfo中构造方法中Object principal
        ActiverUser activerUser = (ActiverUser) principals.getPrimaryPrincipal();
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        return info;
    }
}

~~~



#### F5.5：创建ShiroProperties

~~~java
package com.fclever.config.shiro;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * Shiro的配置信息
 * @author Fclever
 * @create 2020-10-23 13:12
 */
@ConfigurationProperties(prefix = "shiro")
@Data
public class ShiroProperties {

    /**
     * 密码加密方式
     */
    private String hashAlgorithmName = "md5";

    /**
     * 密码散列次数
     */
    private Integer hashIterations = 2;

    /**
     * 放行路径
     */
    private String[] anonUrls;

    /**
     * 拦截路径
     */
    private String[] authcUrls;

}

~~~



#### F5.6：创建ShiroAutoConfiguration

~~~java
package com.fclever.config.shiro;

import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
import org.crazycake.shiro.IRedisManager;
import org.crazycake.shiro.RedisManager;
import org.crazycake.shiro.RedisSessionDAO;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.data.redis.RedisProperties;
import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.filter.DelegatingFilterProxy;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

import javax.servlet.Filter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;

/**
 * Shiro自动配置
 * @author Fclever
 * @create 2020-10-23 13:41
 */
@Configuration
@EnableConfigurationProperties(value = {ShiroProperties.class, RedisProperties.class})
public class ShiroAutoConfiguration {

    // 有了@EnableConfigurationProperties，可以自动注入
    private ShiroProperties shiroProperties;

    // 有了@EnableConfigurationProperties，可以自动注入
    private RedisProperties redisProperties;

    // Shiro过滤器名称
    public static final String SHIRO_FILTER_NAME = "shiroFilter";
    
    
    /**
     * 全参构造器
     * @param shiroProperties
     * @param redisProperties
     */
    public ShiroAutoConfiguration(ShiroProperties shiroProperties, RedisProperties redisProperties) {
        this.shiroProperties = shiroProperties;
        this.redisProperties = redisProperties;
    }

    /**
     * 创建凭证匹配器
     *      将输入的密码进行MD5加密散列两次后与数据库对应密码进行匹配
     *      拿到新密码后与数据库中原有的已经加密过的密码匹配
     */
    @Bean
    public HashedCredentialsMatcher getHashedCredentialsMatcher() {
        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
        // 注入散列算法名   MD5
        matcher.setHashAlgorithmName(shiroProperties.getHashAlgorithmName());
        // 注入散列次数  2次
        matcher.setHashIterations(shiroProperties.getHashIterations());
        return matcher;
    }

    /**
     * 创建自定义realm，并注入凭证匹配器
     * @param matcher 自定义凭证匹配器
     * @return
     */
    @Bean
    @ConditionalOnClass(value = {UserRealm.class})
    public UserRealm getUserRealm(HashedCredentialsMatcher matcher) {
        UserRealm userRealm = new UserRealm();
        // 注入凭证匹配器
        userRealm.setCredentialsMatcher(matcher);
        return userRealm;
    }

    /**
     * 创建安全管理器
     * @param defaultWebSessionManager  默认的session管理器
     * @param userRealm 自定义Realm
     * @return
     */
    @Bean
    @ConditionalOnClass(value = DefaultWebSecurityManager.class)
    public DefaultWebSecurityManager getSecurityManager(DefaultWebSessionManager defaultWebSessionManager, UserRealm userRealm){
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        // 注入自定义Realm
        securityManager.setRealm(userRealm);
        securityManager.setSessionManager(defaultWebSessionManager);
        return securityManager;
    }

    /**
     * 声明过滤器
     * @param securityManager   安全管理器
     * @return
     */
    @Bean(value = SHIRO_FILTER_NAME)
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager){
        // 创建Shiro的过滤器
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        // 注入安全管理器
        bean.setSecurityManager(securityManager);
        // 处理用户未认证访问要认证的地址的跳转问题   默认是跳转到shiroProperties.getLoginUrl()现在改成以json串形式返回
        HashMap<String, Filter> filters = new HashMap<>();
        filters.put("authc", new ShiroLoginFilter());
        bean.setFilters(filters);
        HashMap<String, String> map = new HashMap<>();
        // 配置顺序不能错，先配置不拦截，然后配合拦截
        // 配置不拦截的路径
        String[] anonUrls = shiroProperties.getAnonUrls();
        if (anonUrls != null && anonUrls.length > 0){
            for (String anonUrl : anonUrls) {
                map.put(anonUrl, "anon");
            }
        }

        // 配置需要拦截的路径
        String[] authcUrls = this.shiroProperties.getAuthcUrls();
        if (authcUrls != null && authcUrls.length>0){
        for (String authcUrl : authcUrls) {
            map.put(authcUrl, "authc");
        }
    }
    // 配置过滤器
        bean.setFilterChainDefinitionMap(map);
        return bean;
}

    /**
     * 注册DelegatingFilterProxy
     * @return
     */
    @Bean
    public FilterRegistrationBean<DelegatingFilterProxy> registDelegatingFilterProxy() {
        // 创建注册器
        FilterRegistrationBean<DelegatingFilterProxy> bean = new FilterRegistrationBean<>();
        // 创建过滤器
        DelegatingFilterProxy proxy = new DelegatingFilterProxy();
        // 注入过滤器
        bean.setFilter(proxy);
        proxy.setTargetFilterLifecycle(true);
        proxy.setTargetBeanName(SHIRO_FILTER_NAME);
        Collection<String> servletNames = new ArrayList<>();
        servletNames.add(DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME);
        bean.setServletNames(servletNames);
        return bean;
    }

    /**
     * 分布式项目，要使用redis去存我们的登录session
     * @return
     */
    @Bean
    public IRedisManager redisManager() {
        // 因为RedisManager要操作redis，所以必须把redis的客户端给RedisManager
        RedisManager redisManager = new RedisManager();
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        // 获取yml中配置的redis信息
        JedisPool jedisPool = new JedisPool(jedisPoolConfig, redisProperties.getHost(), redisProperties.getPort(), 10000, redisProperties.getPassword());
        redisManager.setJedisPool(jedisPool);
        return redisManager;
    }

    /**
     * 使用Redis 来存储登录的信息，传递RedisManager给RedisSessionDAO
     * @param redisManager
     * @return  sessionDAO还需要设置给SessionManager
     */
    @Bean
    public RedisSessionDAO redisSessionDAO(IRedisManager redisManager){
        RedisSessionDAO redisSessionDAO = new RedisSessionDAO();
        redisSessionDAO.setRedisManager(redisManager); // 操作哪个redis
        redisSessionDAO.setExpire(7 * 24 * 3600); // 用户的登录信息保存多久？7天
        return redisSessionDAO;
    }

    /**
     * sessionManager里面可以配置sessionDAO
     * @param redisSessionDAO
     * @return
     */
    @Bean
    public DefaultWebSessionManager defaultWebSecurityManager(RedisSessionDAO redisSessionDAO){
        DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();
        defaultWebSessionManager.setSessionDAO(redisSessionDAO);
        return defaultWebSessionManager;
    }

    /*加入注解的使用，不加入这个注解不生效---开始  如果在Controller中需要用到，那么就要加@Bean注解*/
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager){
        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();
        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);
        return authorizationAttributeSourceAdvisor;
    }

    @Bean
    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator(){
        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();
        advisorAutoProxyCreator.setProxyTargetClass(true);
        return advisorAutoProxyCreator;
    }

    /*加入注解的使用，不加入这个注解不生效*/
}

~~~



### F6：LoginController写登录|退出|查询用户信息接口

- 与前端项目保持一致，user.js中

- 代码

  ~~~java
  package com.fclever.controller.system;
  
  import com.fclever.constants.Constants;
  import com.fclever.constants.HttpStatus;
  import com.fclever.domain.Menu;
  import com.fclever.domain.SimpleUser;
  import com.fclever.dto.LoginBodyDto;
  import com.fclever.service.MenuService;
  import com.fclever.vo.ActiverUser;
  import com.fclever.vo.AjaxResult;
  import com.fclever.vo.MenuTreeVo;
  import lombok.extern.log4j.Log4j2;
  import org.apache.shiro.SecurityUtils;
  import org.apache.shiro.authc.UsernamePasswordToken;
  import org.apache.shiro.subject.Subject;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PostMapping;
  import org.springframework.web.bind.annotation.RequestBody;
  import org.springframework.web.bind.annotation.RestController;
  
  import javax.servlet.http.HttpServletRequest;
  import java.io.Serializable;
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * 系统关系登录相关
   * @author Fclever
   * @create 2020-10-26 08:52
   */
  @RestController
  @Log4j2
  public class LoginController {
  
      @Autowired
      private MenuService menuService;
  
      /**
       * 登录方法
       * @param loginBodyDto 保存用户输入的登录数据
       * @param request
       * @return
       */
      @PostMapping("login/doLogin")
      public AjaxResult login(@RequestBody LoginBodyDto loginBodyDto, HttpServletRequest request){
          // 创建统一返回类型对象
          AjaxResult ajaxResult = AjaxResult.success();
          // 获取输入的登录信息
          String username = loginBodyDto.getUsername();
          String password = loginBodyDto.getPassword();
          // 构造含有用户名和密码的token
          UsernamePasswordToken token = new UsernamePasswordToken(username, password);
          Subject subject = SecurityUtils.getSubject();
          try{
              subject.login(token);
              // 如果登录成功，将token保存到redis中
              Serializable webToken = subject.getSession().getId();
              ajaxResult.put(Constants.TOKEN, webToken);
          }catch (Exception e){
              log.error("用户名或密码不正确",e);
              ajaxResult = AjaxResult.error(HttpStatus.ERROR, "用户名或密码不正确");
          }
          return ajaxResult;
      }
  
      /**
       * 获取用户信息
       * @return
       */
      @GetMapping("login/getInfo")
      public AjaxResult getInfo() {
          Subject subject = SecurityUtils.getSubject();
          // 获取当前用户的信息|角色|权限
          // 从redis中获取， 在Shiro中做认证的时候，已经将登录用户输入的一些信息保存在了ActiveUser对象中，进而缓存在Redis中
          ActiverUser activerUser = (ActiverUser) subject.getPrincipal();
          AjaxResult ajax = AjaxResult.success();
          // 用户名|头像|角色|权限
          ajax.put("username", activerUser.getUser().getUserName());
          ajax.put("picture", activerUser.getUser().getPicture());
          ajax.put("roles", activerUser.getRoles());
          ajax.put("permissions", activerUser.getPermissions());
          return ajax;
      }
  
      /**
       * 用户退出
       * @return
       */
      @PostMapping("login/logout")
      public AjaxResult logout(){
          Subject subject = SecurityUtils.getSubject();
          subject.logout();
          return AjaxResult.success("用户退出成功");
      }
  
      /**
       * 获取对应该用户的要显示的菜单
       * @return
       */
      @GetMapping("login/getMenus")
      public AjaxResult getMenus() {
          Subject subject = SecurityUtils.getSubject();
          // 获取当前登录用户信息
          ActiverUser activerUser = (ActiverUser) subject.getPrincipal();
          // 判断类型是否为管理员
          boolean isAdmin = activerUser.getUser().getUserType().equals(Constants.USER_ADMIN);
          // 普通用户
          SimpleUser simpleUser = null;
          // 如果不是超级管理员
          if (!isAdmin){
              simpleUser = new SimpleUser(activerUser.getUser().getUserId(),activerUser.getUser().getUserName());
          }
          // 查询菜单树
          List<Menu> menus = menuService.selectMenuTree(isAdmin, simpleUser);
          // 构造返回给前端的菜单值对象
          List<MenuTreeVo> menuVos = new ArrayList<>();
          for (Menu menu : menus) {
              // 菜单id  和菜单路由地址
              menuVos.add(new MenuTreeVo(menu.getMenuId().toString(), menu.getPath()));
          }
          return AjaxResult.success(menuVos);
      }
  }
  
  ~~~

- 使用Yapi做做接口测试

  - 登录接口
    - ![image-20201027082420154](系统管理.assets/image-20201027082420154.png)
    - ![image-20201027081211879](系统管理.assets/image-20201027081211879.png)
    - ![image-20201027081220776](系统管理.assets/image-20201027081220776.png)
  - 测试获取用户信息接口（需要使用刚刚登录拿到的token）
    - ![image-20201027083119633](系统管理.assets/image-20201027083119633.png)
    - ![image-20201027083743731](系统管理.assets/image-20201027083743731.png)
  - 退出登录
    - ![image-20201027084430879](系统管理.assets/image-20201027084430879.png)
    - ![image-20201027084359349](系统管理.assets/image-20201027084359349.png)
  - 查询菜单信息
    - ![image-20201027085136077](系统管理.assets/image-20201027085136077.png)
    - ![image-20201027085154074](系统管理.assets/image-20201027085154074.png)

### F7：接口数据校验

- 如果出现像输入的密码账号为空这样的情况，就没必要去数据库进行查询了，目前的逻辑是拿到用户输入的账号密码，然后直接根据账号去数据库查用户信息，接着在匹配密码，操作可以省掉

- 改进方法

  - 在进行账号密码匹配之前，就可以对数据校验，如果校验不通过就不进行数据库操作了
  - SpringBoot为我们提供了一套校验规则

- 修改hospital-commons中的pom.xml文件

  ~~~java
  <!--后端数据校验框架-->
          <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-validation</artifactId>
          </dependency>
  ~~~

  如果添加依赖后，还是报错或者找不到注解对应jar包，打开Projects Structure来手动加

- LoginBodyDto中对实体属性使用注解限制

  - ![image-20201027132237598](系统管理.assets/image-20201027132237598.png)

- 如果控制层中验证没有通过时，SpringBoot会抛出异常，这时可以采用全局异常处理类来处理这异常信息

  ~~~java
  package com.fclever.config.exception;
  
  import com.fclever.vo.AjaxResult;
  import org.springframework.web.bind.MethodArgumentNotValidException;
  import org.springframework.web.bind.annotation.ExceptionHandler;
  import org.springframework.web.bind.annotation.RestControllerAdvice;
  
  
  /**
   * 全局异常处理
   * @author Fclever
   * @create 2020-10-27 13:54
   */
  @RestControllerAdvice // Rest会以JSON的形式返回数据
  public class GlobalExceptionHandler {
  
      /**
       * 方法参数无效异常
       * 当系统出现MethodArgumentNotValidException这个异常时，会调用下面的方法
       * @param e
       * @return
       */
      @ExceptionHandler(value = MethodArgumentNotValidException.class)
      public AjaxResult jsonErrorHandler(MethodArgumentNotValidException e){
          return AjaxResult.error(e.getMessage());
      }
  }
  
  ~~~

  

- 使用YApi测试登录，不传递用户名和密码

  - ![image-20201027153749699](系统管理.assets/image-20201027153749699.png)

  - 返回Body值

    ~~~json
    {
      "msg": "Validation failed for argument [0] in public com.fclever.vo.AjaxResult com.fclever.controller.system.LoginController.login(com.fclever.dto.LoginBodyDto,javax.servlet.http.HttpServletRequest) with 2 errors: [Field error in object 'loginBodyDto' on field 'password': rejected value [null]; codes [NotNull.loginBodyDto.password,NotNull.password,NotNull.java.lang.String,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [loginBodyDto.password,password]; arguments []; default message [password]]; default message [密码不能为空]] [Field error in object 'loginBodyDto' on field 'username': rejected value [null]; codes [NotNull.loginBodyDto.username,NotNull.username,NotNull.java.lang.String,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [loginBodyDto.username,username]; arguments []; default message [username]]; default message [用户名不能为空]] ",
      "code": 500,
      "data": null
    }
    ~~~

  - 特别说明：在LoginBody类中属性只是添加了NotNull注解，也就是说对应属性为空时才会触发，比如下面这些情况

    - ![image-20201027154132494](系统管理.assets/image-20201027154132494.png)

  - 传递“”这并不表示为空

### F8：接口数据校验【返回数据优化】

- F7中出现数据校验问题后，返回到前端的数据很多，而且不够明确，比如应该直接明确指出什么原因导致了什么问题

- F7中拿到的校验出错的信息都是通过==e.getMessage()==方法返回的，那么就可以断点调试在这一步，然后取出我们更直观有用的数据即可

  - ![image-20201027155749991](系统管理.assets/image-20201027155749991.png)
  - ![image-20201027155808951](系统管理.assets/image-20201027155808951.png)

- 修改全局异常处理类

  - 第一次修改

    - ![image-20201027160136023](系统管理.assets/image-20201027160136023.png)

  - YApi测试

    - ![image-20201027160125840](系统管理.assets/image-20201027160125840.png)

  - 第二次修改

    ~~~java
    package com.fclever.config.exception;
    
    import com.fclever.vo.AjaxResult;
    import org.springframework.validation.FieldError;
    import org.springframework.validation.ObjectError;
    import org.springframework.web.bind.MethodArgumentNotValidException;
    import org.springframework.web.bind.annotation.ExceptionHandler;
    import org.springframework.web.bind.annotation.RestControllerAdvice;
    
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    
    
    /**
     * 全局异常处理
     * @author Fclever
     * @create 2020-10-27 13:54
     */
    @RestControllerAdvice // Rest会以JSON的形式返回数据
    public class GlobalExceptionHandler {
    
        /**
         * 方法参数无效异常
         * 当系统出现MethodArgumentNotValidException这个异常时，会调用下面的方法
         * @param e
         * @return
         */
        @ExceptionHandler(value = MethodArgumentNotValidException.class)
        public AjaxResult jsonErrorHandler(MethodArgumentNotValidException e){
            List<Map<String,Object>> list = new ArrayList<>();
            List<ObjectError> allErrors = e.getBindingResult().getAllErrors();
            for (ObjectError allError : allErrors) {
                Map<String, Object> map = new HashMap<>();
                map.put("defaultMessage", allError.getDefaultMessage());
                map.put("objectName", allError.getObjectName());
                // 转换类型，获取属性 FieldError extends ObjectError
                // field属性需要从FieldError获取
                FieldError fieldError = (FieldError)allError;
                map.put("field", fieldError.getField());
                list.add(map);
            }
            return AjaxResult.fail("后端数据校验异常", list);
        }
    }
    
    ~~~

    

  - YApi测试

    - ![image-20201027165455453](系统管理.assets/image-20201027165455453.png)

## 前端

### F9：用户登录

#### F9.1：登录

##### F9.1.1：修改view/login/index.vue，设置默认填充的用户名和密码

~~~vue
<template>
  <div class="login-container">
    <el-form ref="loginForm" :model="loginForm" :rules="loginRules" class="login-form" autocomplete="on" label-position="left">

      <div class="title-container">
        <h3 class="title">online-hospital在线医疗平台管理系统</h3>
      </div>

      <el-form-item prop="username">
        <span class="svg-container">
          <svg-icon icon-class="user" />
        </span>
        <el-input
          ref="username"
          v-model="loginForm.username"
          placeholder="请输入用户名"
          name="username"
          type="text"
          tabindex="1"
          autocomplete="on"
        />
      </el-form-item>

      <el-tooltip v-model="capsTooltip" content="Caps lock is On" placement="right" manual>
        <el-form-item prop="password">
          <span class="svg-container">
            <svg-icon icon-class="password" />
          </span>
          <el-input
            :key="passwordType"
            ref="password"
            v-model="loginForm.password"
            :type="passwordType"
            placeholder="请输入密码"
            name="password"
            tabindex="2"
            autocomplete="on"
            @keyup.native="checkCapslock"
            @blur="capsTooltip = false"
            @keyup.enter.native="handleLogin"
          />
          <span class="show-pwd" @click="showPwd">
            <svg-icon :icon-class="passwordType === 'password' ? 'eye' : 'eye-open'" />
          </span>
        </el-form-item>
      </el-tooltip>

      <el-button :loading="loading" type="primary" style="width:100%;margin-bottom:30px;" @click.native.prevent="handleLogin">登录</el-button>

      <div style="position:relative">
<!--        <div class="tips">-->
<!--          <span>Username : admin</span>-->
<!--          <span>Password : any</span>-->
<!--        </div>-->
<!--        <div class="tips">-->
<!--          <span style="margin-right:18px;">Username : editor</span>-->
<!--          <span>Password : any</span>-->
<!--        </div>-->
        <br/> <br/>
        <el-button class="thirdparty-button" type="primary" @click="showDialog=true">
          第三方登录
        </el-button>
      </div>
    </el-form>

    <el-dialog title="第三方登录" :visible.sync="showDialog">
      请选择第三方登录的方式（目前接口暂未开发）
      <br>
      <br>
      <br>
      <social-sign />
    </el-dialog>
  </div>
</template>

<script>
// import { validUsername } from '@/utils/validate'
import SocialSign from './components/SocialSignin'

export default {
  name: 'Login',
  components: { SocialSign },
  data() {
    // const validateUsername = (rule, value, callback) => {
    //   if (!validUsername(value)) {
    //     callback(new Error('请输入正确的用户名'))
    //   } else {
    //     callback()
    //   }
    // }
    const validatePassword = (rule, value, callback) => {
      if (value.length < 6) {
        callback(new Error('密码不能少于6位数'))
      } else {
        callback()
      }
    }
    return {
      // 默认填充在页面中的账号密码
      loginForm: {
        username: '13888001001',
        password: '001001'
      },
      loginRules: {
        // username: [{ required: true, trigger: 'blur', validator: validateUsername }],
        password: [{ required: true, trigger: 'blur', validator: validatePassword }]
      },
      passwordType: 'password',
      capsTooltip: false,
      loading: false,
      showDialog: false,
      redirect: undefined,
      otherQuery: {}
    }
  },
  watch: {
    $route: {
      handler: function(route) {
        const query = route.query
        if (query) {
          this.redirect = query.redirect
          this.otherQuery = this.getOtherQuery(query)
        }
      },
      immediate: true
    }
  },
  created() {
    // window.addEventListener('storage', this.afterQRScan)
  },
  mounted() {
    if (this.loginForm.username === '') {
      this.$refs.username.focus()
    } else if (this.loginForm.password === '') {
      this.$refs.password.focus()
    }
  },
  destroyed() {
    // window.removeEventListener('storage', this.afterQRScan)
  },
  methods: {
    checkCapslock(e) {
      const { key } = e
      this.capsTooltip = key && key.length === 1 && (key >= 'A' && key <= 'Z')
    },
    showPwd() {
      if (this.passwordType === 'password') {
        this.passwordType = ''
      } else {
        this.passwordType = 'password'
      }
      this.$nextTick(() => {
        this.$refs.password.focus()
      })
    },
    // 处理登录逻辑
    handleLogin() {
      // 对表单数据进行校验
      this.$refs.loginForm.validate(valid => {
        // 对用户名和密码做合法校验  这里仅仅是前端验证
        if (valid) {
          this.loading = true
          // 调用登录的方法
          this.$store.dispatch('user/login', this.loginForm)
            .then(() => {
              // 如果登录后端验证成功，则跳转到系统主页
              this.$router.push({ path: this.redirect || '/', query: this.otherQuery })
              this.loading = false
            })
            .catch(() => {
              this.loading = false
            })
        } else {
          // 数据校验未通过
          console.log('error submit!!')
          return false
        }
      })
    },
    getOtherQuery(query) {
      return Object.keys(query).reduce((acc, cur) => {
        if (cur !== 'redirect') {
          acc[cur] = query[cur]
        }
        return acc
      }, {})
    }
    // afterQRScan() {
    //   if (e.key === 'x-admin-oauth-code') {
    //     const code = getQueryObject(e.newValue)
    //     const codeMap = {
    //       wechat: 'code',
    //       tencent: 'code'
    //     }
    //     const type = codeMap[this.auth_type]
    //     const codeName = code[type]
    //     if (codeName) {
    //       this.$store.dispatch('LoginByThirdparty', codeName).then(() => {
    //         this.$router.push({ path: this.redirect || '/' })
    //       })
    //     } else {
    //       alert('第三方登录失败')
    //     }
    //   }
    // }
  }
}
</script>

<style lang="scss">
/* 修复input 背景不协调 和光标变色 */
/* Detail see https://github.com/PanJiaChen/vue-element-admin/pull/927 */

$bg:#283443;
$light_gray:#fff;
$cursor: #fff;

@supports (-webkit-mask: none) and (not (cater-color: $cursor)) {
  .login-container .el-input input {
    color: $cursor;
  }
}

/* reset element-ui css */
.login-container {
  .el-input {
    display: inline-block;
    height: 47px;
    width: 85%;

    input {
      background: transparent;
      border: 0px;
      -webkit-appearance: none;
      border-radius: 0px;
      padding: 12px 5px 12px 15px;
      color: $light_gray;
      height: 47px;
      caret-color: $cursor;

      &:-webkit-autofill {
        box-shadow: 0 0 0px 1000px $bg inset !important;
        -webkit-text-fill-color: $cursor !important;
      }
    }
  }

  .el-form-item {
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
    color: #454545;
  }
}
</style>

<style lang="scss" scoped>
$bg:#2d3a4b;
$dark_gray:#889aa4;
$light_gray:#eee;

.login-container {
  min-height: 100%;
  width: 100%;
  background-color: $bg;
  overflow: hidden;

  .login-form {
    position: relative;
    width: 520px;
    max-width: 100%;
    padding: 160px 35px 0;
    margin: 0 auto;
    overflow: hidden;
  }

  .tips {
    font-size: 14px;
    color: #fff;
    margin-bottom: 10px;

    span {
      &:first-of-type {
        margin-right: 16px;
      }
    }
  }

  .svg-container {
    padding: 6px 5px 6px 15px;
    color: $dark_gray;
    vertical-align: middle;
    width: 30px;
    display: inline-block;
  }

  .title-container {
    position: relative;

    .title {
      font-size: 26px;
      color: $light_gray;
      margin: 0px auto 40px auto;
      text-align: center;
      font-weight: bold;
    }
  }

  .show-pwd {
    position: absolute;
    right: 10px;
    top: 7px;
    font-size: 16px;
    color: $dark_gray;
    cursor: pointer;
    user-select: none;
  }

  .thirdparty-button {
    position: absolute;
    right: 0;
    bottom: 6px;
  }

  @media only screen and (max-width: 470px) {
    .thirdparty-button {
      display: none;
    }
  }
}
</style>

~~~



##### F9.1.2：修改store/modules/user.js

~~~js
import { login, logout, getInfo } from '@/api/user'
import { getToken, setToken, removeToken } from '@/utils/auth'
// import router, { resetRouter } from '@/router'
import { resetRouter } from '@/router'

const state = {
  token: getToken(),
  username: '',
  picture: '',
  // introduction: '',
  roles: [],
  permissions: []
}

const mutations = {
  SET_TOKEN: (state, token) => {
    state.token = token
  },
  // SET_INTRODUCTION: (state, introduction) => {
  //   state.introduction = introduction
  // },
  SET_USERNAME: (state, username) => {
    state.username = username
  },
  SET_PICTURE: (state, picture) => {
    state.picture = picture
  },
  SET_ROLES: (state, roles) => {
    state.roles = roles
  },
  SET_PERMISSIONS: (state, permissions) => {
    state.permissions = permissions
  }
}

const actions = {
  // 用户登录
  login({ commit }, userInfo) {
    // 从userInfo中取出用户名和密码
    const { username, password } = userInfo
    return new Promise((resolve, reject) => {
      // 调用api/user.js中的方法，向后端发送请求
      login({ username: username.trim(), password: password }).then(response => {
        // 响应数据格式根据YApi来看，与原来不同了
        const { token } = response
        // 登录成功后，从响应数据中获取token，保存到Vuex中
        // commit调用了mutations中的SET_TOKEN方法保存了token信息
        commit('SET_TOKEN', token)
        setToken(token)
        resolve()
      }).catch(error => {
        reject(error)
      })
    })
  },

  // 获取用户信息
  getInfo({ commit, state }) {
    return new Promise((resolve, reject) => {
      getInfo(state.token).then(response => {
        // const { data } = response
        // if (!data) {
        //   reject('Verification failed, please Login again.')
        // }
        const { username, picture, roles, permissions } = response

        // roles must be a non-empty array
        // if (!roles || roles.length <= 0) {
        //   reject('getInfo: roles must be a non-null array!')
        // }
        if (!username) {
          reject('用户名为空，请重新登录!')
        }
        // 获取角色
        commit('SET_ROLES', roles)
        // 获取用户名
        commit('SET_NAME', username)
        // 获取头像
        commit('SET_PICTURE', picture)
        // 获取权限
        commit('SET_PERMISSIONS', permissions)
        // 获取介绍
        // commit('SET_INTRODUCTION', introduction)
        resolve(response)
      }).catch(error => {
        reject(error)
      })
    })
  },

  // 退出登录
  logout({ commit, state, dispatch }) {
    return new Promise((resolve, reject) => {
      logout(state.token).then(() => {
        // 清空了token信息（在Vuex中）
        commit('SET_TOKEN', '')
        // 清空了角色信息（在Vuex中）
        commit('SET_ROLES', [])
        // 清空权限
        commit('SET_PERMISSIONS', [])
        // 删除token
        removeToken()
        // 重置路由
        resetRouter()

        // reset visited views and cached views
        // to fixed https://github.com/PanJiaChen/vue-element-admin/issues/2485
        dispatch('tagsView/delAllViews', null, { root: true })

        resolve()
      }).catch(error => {
        reject(error)
      })
    })
  },

  // remove token
  resetToken({ commit }) {
    return new Promise(resolve => {
      // 清空token
      commit('SET_TOKEN', '')
      // 清空角色
      commit('SET_ROLES', [])
      // 清空权限
      commit('SET_PERMISSIONS', [])
      removeToken()
      resolve()
    })
  }

  // 动态改变权限
  // async changeRoles({ commit, dispatch }, role) {
  //   const token = role + '-token'
  //
  //   commit('SET_TOKEN', token)
  //   setToken(token)
  //
  //   const { roles } = await dispatch('getInfo')
  //
  //   resetRouter()
  //
  //   // generate accessible routes map based on roles
  //   const accessRoutes = await dispatch('permission/generateRoutes', roles, { root: true })
  //   // dynamically add accessible routes
  //   router.addRoutes(accessRoutes)
  //
  //   // reset visited views and cached views
  //   dispatch('tagsView/delAllViews', null, { root: true })
  // }
}

export default {
  namespaced: true,
  state,
  mutations,
  actions
}

~~~



##### F9.1.3：修改src/api/user.js的真实API

~~~js
import request from '@/utils/request'

// 登录的后端接口
export function login(data) {
  // 向后端发送了一个post请求
  return request({
    url: '/login/doLogin',
    method: 'post',
    data // data是username和password
  })
}

// 登录成功之后获取用户信息的接口
export function getInfo(token) {
  return request({
    url: '/login/getInfo',
    method: 'get',
    params: { token }
  })
}

// 退出登录的接口
export function logout() {
  return request({
    url: '/login/logout',
    method: 'post'
  })
}

~~~

- 此时可以登录测试，看是否能成功，需要启动后端项目和虚拟机
- ![image-20201028072146857](系统管理.assets/image-20201028072146857.png)
- 点击登录之后，发现并没有登录成功，在这里可以看到我们在api/user.js中配置的请求路径是/login/doLogin，此时前面添加了一个/dev-api的前缀，该前缀是在.env.development中配置的

##### F9.1.4：修改.env.development开发环境变量（这里没有修改）

~~~js
# just a flag
ENV = 'development'

# base api
VUE_APP_BASE_API = '/dev-api'

~~~



##### F9.1.5：修改vue.config.js配置代理

- 因为前后端分离，前后端在两个服务上配置，前端调用后端接口的时候肯定要进行跨域，而Vue提供了在前端处理跨域的解决方式

~~~js
'use strict'
const path = require('path')
const defaultSettings = require('./src/settings.js')

function resolve(dir) {
  return path.join(__dirname, dir)
}

const name = defaultSettings.title || 'vue Element Admin' // page title

// If your port is set to 80,
// use administrator privileges to execute the command line.
// For example, Mac: sudo npm run
// You can change the port by the following method:
// port = 9527 npm run dev OR npm run dev --port = 9527
// 修改项目的访问端口，如果为80，浏览器地址栏默认不显示
const port = process.env.port || process.env.npm_config_port || 80 // dev port

// All configuration item explanations can be find in https://cli.vuejs.org/config/
module.exports = {
  /**
   * You will need to set publicPath if you plan to deploy your site under a sub path,
   * for example GitHub Pages. If you plan to deploy your site to https://foo.github.io/bar/,
   * then publicPath should be set to "/bar/".
   * In most cases please use '/' !!!
   * Detail: https://cli.vuejs.org/config/#publicpath
   */
  publicPath: '/',
  outputDir: 'dist',
  assetsDir: 'static',
  lintOnSave: process.env.NODE_ENV === 'development',
  productionSourceMap: false,
  devServer: {
    port: port,
    open: true,
    overlay: {
      warnings: false,
      errors: true
    },
    // 这里提供了模拟数据，后期删除
    // before: require('./mock/mock-server.js')
    // 跨域代理配置
    proxy: {
      [process.env.VUE_APP_BASE_API]: {
        target: 'http://127.0.0.1:8080/', // 地址为后端服务器的地址
        changeOrigin: true,
        pathRewrite: {
          ['^' + process.env.VUE_APP_BASE_API]: ''
        }
      }
    }
  },
  configureWebpack: {
    // provide the app's title in webpack's name field, so that
    // it can be accessed in index.html to inject the correct title.
    name: name,
    resolve: {
      alias: {
        '@': resolve('src')
      }
    }
  },
  chainWebpack(config) {
    // it can improve the speed of the first screen, it is recommended to turn on preload
    // it can improve the speed of the first screen, it is recommended to turn on preload
    config.plugin('preload').tap(() => [
      {
        rel: 'preload',
        // to ignore runtime.js
        // https://github.com/vuejs/vue-cli/blob/dev/packages/@vue/cli-service/lib/config/app.js#L171
        fileBlacklist: [/\.map$/, /hot-update\.js$/, /runtime\..*\.js$/],
        include: 'initial'
      }
    ])

    // when there are many pages, it will cause too many meaningless requests
    config.plugins.delete('prefetch')

    // set svg-sprite-loader
    config.module
      .rule('svg')
      .exclude.add(resolve('src/icons'))
      .end()
    config.module
      .rule('icons')
      .test(/\.svg$/)
      .include.add(resolve('src/icons'))
      .end()
      .use('svg-sprite-loader')
      .loader('svg-sprite-loader')
      .options({
        symbolId: 'icon-[name]'
      })
      .end()

    config
      .when(process.env.NODE_ENV !== 'development',
        config => {
          config
            .plugin('ScriptExtHtmlWebpackPlugin')
            .after('html')
            .use('script-ext-html-webpack-plugin', [{
            // `runtime` must same as runtimeChunk name. default is `runtime`
              inline: /runtime\..*\.js$/
            }])
            .end()
          config
            .optimization.splitChunks({
              chunks: 'all',
              cacheGroups: {
                libs: {
                  name: 'chunk-libs',
                  test: /[\\/]node_modules[\\/]/,
                  priority: 10,
                  chunks: 'initial' // only package third parties that are initially dependent
                },
                elementUI: {
                  name: 'chunk-elementUI', // split elementUI into a single package
                  priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app
                  test: /[\\/]node_modules[\\/]_?element-ui(.*)/ // in order to adapt to cnpm
                },
                commons: {
                  name: 'chunk-commons',
                  test: resolve('src/components'), // can customize your rules
                  minChunks: 3, //  minimum common number
                  priority: 5,
                  reuseExistingChunk: true
                }
              }
            })
          // https:// webpack.js.org/configuration/optimization/#optimizationruntimechunk
          config.optimization.runtimeChunk('single')
        }
      )
  }
}

~~~



##### F9.1.6：配置代理之后要重启项目

##### F9.1.7：测试

- 重新登录进行测试
  - ![image-20201028073422076](系统管理.assets/image-20201028073422076.png)
- 可以看到已经登录成功，并拿到相应数据了，但是页面并未跳转，而且提示Error

#### F9.2：解决登录成功之后不跳转的问题

- 原因：前置拦截和后置拦截处理的问题

- 修改src/utils/request.js

  ~~~js
  import axios from 'axios'
  import { MessageBox, Message } from 'element-ui'
  import store from '@/store'
  import { getToken } from '@/utils/auth'
  
  // 创建一个axios实例
  const service = axios.create({
    baseURL: process.env.VUE_APP_BASE_API, // 实际发送的URL=baseURL  +  请求配置的url  （baseURL当前就是/dev-api
    // withCredentials: true, // send cookies when cross-domain requests
    timeout: 5000 // 设置请求超时时间
  })
  
  // 请求拦截器
  service.interceptors.request.use(
    config => {
      // 在发送请求之前做的事情
      if (store.getters.token) {
        // 让每一个请求中都携带token
        // 【‘X-Token’】是一个自定义的header中的key
        // 可以根据实际情况改变它
        // 这里的token名称要和后端保持一致
        config.headers['token'] = getToken()
      }
      return config
    },
    error => {
      // 当请求出现问题时所做的一些事情
      console.log(error) // for debug
      return Promise.reject(error)
    }
  )
  
  // 响应拦截器
  service.interceptors.response.use(
    /**
     * 如果你想要得到诸如请求头或者状态的http信息
     * 请返回  response => response
     */
    /**
     * 通过自定义码来决定请求状态
     * 这里仅仅是一个例子
     * 你同样也可以根据http的状态码来决定这个状态
     * @param response
     * @returns {any|Promise<AxiosResponse<any>>}
     */
    response => {
      /**
       * 项目中存在的状态码
       * 400：参数存在问题
       * 401：未授权
       * 500：系统内部错误
       * 200：操作成功
       */
      const res = response.data // response.data才是后台返回给我们的数据
      if (res.code === 401) {
        // 未授权，身份过期  一个弹出框
        MessageBox.confirm('用户登录身份已过期，请重新登录', '系统提示', {
          confirmButtonText: '重新登录',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          store.dispatch('user/logout').then(() => { // 跳转到登录页面重新登录
            location.reload()
          })
        })
      } else if (res.code === 500) {
        Notification.error({
          title: '服务器内部出现异常，请联系管理员'
        })
        return Promise.reject('error') // 记录错误
      } else if (res.code !== 200) { // 可能是其他参数出错
        Notification.error({
          title: res.msg
        })
        return Promise.reject('error') // 记录错误
      } else {
        // 以上验证通过之后放行
        return res
      }
      // 如果响应的code值不是200，那么就判别为一个error
      // if (res.code !== 200) {
      //   Message({
      //     message: res.message || 'Error',
      //     type: 'error',
      //     duration: 5 * 1000
      //   })
      //
      //   // 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired;
      //   if (res.code === 50008 || res.code === 50012 || res.code === 50014) {
      //     // to re-login
      //     MessageBox.confirm('You have been logged out, you can cancel to stay on this page, or log in again', 'Confirm logout', {
      //       confirmButtonText: 'Re-Login',
      //       cancelButtonText: 'Cancel',
      //       type: 'warning'
      //     }).then(() => {
      //       store.dispatch('user/resetToken').then(() => {
      //         location.reload()
      //       })
      //     })
      //   }
      //   return Promise.reject(new Error(res.message || 'Error'))
      // } else {
      //   return res
      // }
    },
    error => {
      console.log('err' + error) // for debug
      Message({
        message: error.message,
        type: 'error',
        duration: 5 * 1000
      })
      return Promise.reject(error)
    }
  )
  
  export default service
  
  ~~~

  

- 修改src/permission.js

  ~~~js
  import router from './router'
  import store from './store'
  import { Message } from 'element-ui'
  import NProgress from 'nprogress' // progress bar
  import 'nprogress/nprogress.css' // progress bar style
  import { getToken } from '@/utils/auth' // get token from cookie
  import getPageTitle from '@/utils/get-page-title'
  
  NProgress.configure({ showSpinner: false }) // NProgress Configuration
  
  const whiteList = ['/login', '/auth-redirect'] // no redirect whitelist
  
  // 全局前置守卫，触发任意导航时，都会触发全局前置守卫
  router.beforeEach(async(to, from, next) => {
    // 开始进度条
    NProgress.start()
  
    // 设置网页标题
    document.title = getPageTitle(to.meta.title)
  
    // 获取页面的token信息，判断用户是否已经登录
    const hasToken = getToken()
  
    if (hasToken) {
      // 已经登录了，判断请求路由是否为login，如果是login则不需要重复登录，直接跳转到首页即可
      if (to.path === '/login') {
        // 如果已经登录过了，那么跳转到首页
        next({ path: '/' })
        NProgress.done() // hack: https://github.com/PanJiaChen/vue-element-admin/pull/2939
      } else {
        // 如果请求路由不是去往登录页面，那么就需要判断当前用户的角色，来决定能否跳转到目标路由
        // 确定用户是否通过getInfo获得了他的角色
        // const hasRoles = store.getters.roles && store.getters.roles.length > 0
        // 目前角色都是空的，所以先以用户名来判断
        const hasUsername = store.getters.name !== ''
        // 如果已经获得了角色，那么就可以跳转到目标路由
        // -- 如果用户名不为空，表示已经登录过
        if (hasUsername) {
          next()
        } else {
          // 如果没有对应的角色，那么就需要请求后台获取用户信息和权限信息
          try {
            // 说明：角色必须是一个对象数组类型，比如【‘admin’】或者【‘developer’，‘editor’】
            // const { roles } = await store.dispatch('user/getInfo')
            await store.dispatch('user/getInfo')
  
            // 基于角色生成动态路由【菜单和权限】
            // 默认先给一个admin权限
            const accessRoutes = await store.dispatch('permission/generateRoutes', ['admin'])
  
            // 动态添加路由
            router.addRoutes(accessRoutes)
  
            // hack方法，以确保addRoutes是完整的
            // 设置replace: true，这样导航将不会留下历史记录
            next({ ...to, replace: true })
          } catch (error) {
            // 如果出错，则请求后台重置用户token并且跳转到登录页面，重新登录
            await store.dispatch('user/resetToken')
            Message.error(error || 'Has Error')
            next(`/login?redirect=${to.path}`)
            NProgress.done()
          }
        }
      }
    } else {
      /* has no token*/
      // 没有token，需要登录
      if (whiteList.indexOf(to.path) !== -1) {
        // in the free login whitelist, go directly
        // 如果在免登陆白名单中，则直接不需登录直接进入
        next()
      } else {
        // 否则将被重定向到登录页面
        next(`/login?redirect=${to.path}`)
        NProgress.done()
      }
    }
  })
  
  // 全局后置钩子
  router.afterEach(() => {
    // finish progress bar
    NProgress.done()
  })
  
  ~~~

- 修改store/modules/permission.js

  ~~~js
  import { asyncRoutes, constantRoutes } from '@/router'
  
  /**
   * Use meta.role to determine if the current user has permission
   * @param roles
   * @param route
   */
  function hasPermission(roles, route) {
    if (route.meta && route.meta.roles) {
      return roles.some(role => route.meta.roles.includes(role))
    } else {
      return true
    }
  }
  
  /**
   * Filter asynchronous routing tables by recursion
   * @param routes asyncRoutes
   * @param roles
   */
  export function filterAsyncRoutes(routes, roles) {
    const res = []
  
    routes.forEach(route => {
      const tmp = { ...route }
      if (hasPermission(roles, tmp)) {
        if (tmp.children) {
          tmp.children = filterAsyncRoutes(tmp.children, roles)
        }
        res.push(tmp)
      }
    })
  
    return res
  }
  
  const state = {
    routes: [],
    addRoutes: []
  }
  
  const mutations = {
    SET_ROUTES: (state, routes) => {
      state.addRoutes = routes
      state.routes = constantRoutes.concat(routes)
    }
  }
  
  const actions = {
    generateRoutes({ commit }, roles) {
      return new Promise(resolve => {
        let accessedRoutes
        // 如果角色包含admin，那就进行动态路由
        if (roles.includes('admin')) {
          accessedRoutes = asyncRoutes || []
        } else {
          // 否则进行过滤
          accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)
        }
        commit('SET_ROUTES', accessedRoutes)
        resolve(accessedRoutes)
      })
    }
  }
  
  export default {
    namespaced: true,
    state,
    mutations,
    actions
  }
  
  ~~~

  

- 重新测试结果

  - ![image-20201028081650745](系统管理.assets/image-20201028081650745.png)

- 查看结果问题

  - 可以看到登录进入后显示的首页并不是统计的那个页面

  - 修改views/dashboard/index.vue

    ~~~vue
    <template>
      <div class="dashboard-container">
        <component :is="currentRole" />
      </div>
    </template>
    
    <script>
    // import { mapGetters } from 'vuex'
    import adminDashboard from './admin'
    import editorDashboard from './editor'
    
    export default {
      name: 'Dashboard',
      components: { adminDashboard, editorDashboard },
      data() {
        return {
          currentRole: 'adminDashboard'
        }
      }
      // computed: {
      //   ...mapGetters([
      //     'roles'
      //   ])
      // },
      // created() {
      //   if (!this.roles.includes('admin')) {
      //     this.currentRole = 'editorDashboard'
      //   }
      // }
    }
    </script>
    
    ~~~

    

#### F9.3：解决其他问题

- 面包屑的问题及控制台报错
  - ![image-20201028082232613](系统管理.assets/image-20201028082232613.png)
  - 多了一个Dashboard的显示
  - ![image-20201028082220261](系统管理.assets/image-20201028082220261.png)
- 找到src/components/Breadcrumb/index.vue修改
  - ![image-20201028151219139](系统管理.assets/image-20201028151219139.png)

### F10：登录额加载菜单和后台关联问题

#### F10.1：加载菜单方案选择

- 概述
  - 目前系统中显示的菜单都是写死的数据，并没有从数据库的菜单表中查询获取，菜单表中每一个菜单都有path属性，我们可以根据path属性来控制是否显示该菜单
  - 使用vue-element-admin过程中，可以发现其中的菜单列表是通过遍历路由进行渲染的，由前端定义，可以在router.js中可以看到已经写死的路由信息，路由即菜单
    - ![image-20201029090140871](系统管理.assets/image-20201029090140871.png)
  - 好处是不同重复定义菜单列表信息和路由之间的绑定了；但是我们的菜单信息想要通过服务端进行动态输出来达到权限控制的效果就不是那么容易了。
  - 现在很多解决方案是由服务端输出完整的vue-element-admin路由信息并进行绑定，这样虽然能够达到动态菜单的效果，但是给服务端造成了不必要的烦恼。
  - 作为服务端开发：不关心菜单对应于哪个vue组件，也不希望将菜单的格式限定的过于严格，甚至不关心菜单的图标是什么，只需要严格按照服务端的要求显示或者隐藏菜单即可。
  - 最终选择方案：服务端只控制菜单显示或者隐藏，路由信息定义在前端，达到完美的前后端分离要求
- 两种方案
  - 所有的路由地址由后端提供，异步渲染
  - 所有的路由由前端提供，后台提供数据确定起那段哪些路径隐藏

#### F10.2：开始修改

##### F10.2.1：定义路由

- 在src/router/index.js中，常量路由为共用的一些路由，不会因为登录用户所属角色不同而改变，在动态路由ayncRoutes中每个路由都含有name属性，而且数据库的菜单表中存在path属性，==这里就可以根据name值与path的值的匹配==来动态决定菜单是否显示了
- src/router/index.js中的路由配置
  - ![image-20201030083620594](系统管理.assets/image-20201030083620594.png)

##### F10.2.2：服务端接口

- 服务端接口获取菜单信息的接口返回数据
  - ![image-20201030084728418](系统管理.assets/image-20201030084728418.png)

##### F10.2.3：修改api请求模块

- 添加菜单接口配置
  - ![image-20201030085234974](系统管理.assets/image-20201030085234974.png)

##### F10.2.4：配置store调用

- 项目中原本加载菜单的方式是在src/permission.js中进行加载的，这里不直接修改以下代码，新增一个关于菜单的js
  
- ![image-20201030085209722](系统管理.assets/image-20201030085209722.png)
  
- 添加src/store/modules/menu.js

  ~~~js
  // 引入路由
  import { asyncRoutes, constantRoutes, lastRoute } from '@/router'
  // 引入api中获取菜单信息的接口
  import { getMenus } from '@/api/user'
  
  const state = {
    routes: []
  }
  // 保存菜单信息到Vuex中
  const mutations = {
    SET_ROUTES: (state, routes) => {
      state.routes = routes
    }
  }
  
  // 动态菜单定义在前端，后台只会返回对应登录用户有权限的菜单列表，通过遍历服务端的菜单数据，将没有获取到的菜单进行隐藏
  // 这样的好处是服务端无需返回前端菜单相关结果，并且菜单显示又可以通过服务端来控制，进行菜单的动态控制
  // 遵循了前后端分离的原则
  
  // routes：前端定义写死的异步路由信息,srvMenus：从服务端获取的菜单信息，
  function generateRoutes(routes, srvMenus) {
    // 遍历前端写死的异步路由列表
    for (let i = 0; i < routes.length; i++) {
      // 单个对象
      const routeItem = routes[i]
      // 设置默认不显示
      var showItem = false
      // 遍历服务端返回的当前用户可以操作的菜单
      for (let j = 0; j < srvMenus.length; j++) {
        // 单个对象
        const srvItem = srvMenus[j]
        // 如果前端路由对应不是undefined 并且 前端路由的name与服务端路由的name相等，且服务端菜单show为true
        // 前后端数据通过 serPath 属性来匹配
        if (routeItem.name !== undefined && routeItem.name === srvItem.serPath && srvItem.show === true) {
          // 那么该前端路由菜单需要显示
          showItem = true
          // 隐藏属性设置为false
          routes[i]['hidden'] = false
          break
        }
      }
      // 如果遍历的单个前端路由菜单依旧是false，表示并没有和服务端返回的菜单数据匹配，那么设置hidden为true
      if (showItem === false) {
        routes[i]['hidden'] = true
      }
      /**
       * 下面的if判断是否可以放入break前面呢？如果一级菜单都不行，那么二级菜单肯定也不能显示
       * 上面如果showItem已经判断为false，表示一级菜单不能显示，就算一级菜单下面还有二级菜单还有什么意义呢
        */
      // 深层次遍历子节点，如果当前前端菜单的children子节点不为空，并且长度大于0，那么继续匹配子菜单节点是否显示
      if (routeItem['children'] !== undefined && routeItem['children'].length > 0) {
        generateRoutes(routes[i]['children'], srvMenus)
      }
    }
  }
  
  const actions = {
    getMenus({ commit }, roles) {
      return new Promise(resolve => {
        // 查询与当前登录用户角色的菜单数据
        getMenus(state.token).then(async function(res) {
          // res:{“msg":"","code":"","data":[{"id":"","serPath":"","show":boolean},{}....]
          // 获取服务端返回的菜单数组对象
          const srvMenus = res.data
          // 获取异步路由对象
          var pushRouter = asyncRoutes
          // 根据服务端返回的菜单与前端定义的菜单数据进行匹配
          generateRoutes(pushRouter, srvMenus)
          // 定义常量保存实际需要显示的菜单信息
          const routeArr = []
          // 保存常量路由
          routeArr.push(...constantRoutes)
          // 保存与服务端动态匹配的路由
          routeArr.push(...pushRouter)
          // 保存
          routeArr.push(...lastRoute)
          commit('SET_ROUTES', routeArr)// 放到vuex里面
          resolve(routeArr)
        })
      })
    }
  }
  
  export default {
    namespaced: true,
    state,
    mutations,
    actions
  }
  
  ~~~

  

##### F10.2.5：修改store/getters.js

~~~js
const getters = {
  sidebar: state => state.app.sidebar,
  size: state => state.app.size,
  device: state => state.app.device,
  visitedViews: state => state.tagsView.visitedViews,
  cachedViews: state => state.tagsView.cachedViews,
  token: state => state.user.token,
  avatar: state => state.user.avatar,
  name: state => state.user.name,
  introduction: state => state.user.introduction,
  roles: state => state.user.roles,
  permission_routes: state => state.permission.routes,
  errorLogs: state => state.errorLog.logs,
  menuRoutes: state => state.menu.routes // 实际显示的菜单
}
export default getters

~~~



##### F10.2.6：动态渲染菜单修改src/permission.js

- ![image-20201101133807181](系统管理.assets/image-20201101133807181.png)

##### F10.2.7：登录测试--菜单不显示问题

- ![image-20201101161744828](系统管理.assets/image-20201101161744828.png)
- 问题原因
  - 默认系统中，主页面上加载菜单的数据是使用的modules/permission.js助攻的路由数据，现在更换了新的数据，要改变主页面中菜单的数据引用

##### F10.2.8：修改加载菜单取数据的参数

- src/layout/components/Sidebar/index.vue
  - ![image-20201101172941298](系统管理.assets/image-20201101172941298.png)
  - ![image-20201101173124770](系统管理.assets/image-20201101173124770.png)

##### F10.2.9：修改完登录加载可以了

- 登录系统测试
  - ![image-20201101173208984](系统管理.assets/image-20201101173208984.png)

##### F10.2.10：修改数据库测试

- 将sys_menu表中一些菜单的status设置为1，然后刷新系统看对应菜单是否会显示，如果不显示那么就对了

# 字典类型管理

## 介绍

- 为什么将字段类型管理作为第一个内容进行开发？
  - 因为这里涉及的内容与其他各个模块很有关系，其他模块一些码表数据都是由字典类型管理模块来控制的（增删改查）
- 涉及到的数据库表（类型对应多个数据）
  - 字典类型表：sys_dict_type
  - 字段数据表：sys_dict_data
- YApi添加字典类型管理的接口文档
  - 以后这一块就不再单独写了，直接个人空间查看就行了

## 后端

### F1：生成字典类型相关代码

- 数据表：sys_dict_type
  - ![image-20201102174300981](系统管理.assets/image-20201102174300981.png)
  - ![image-20201102174604022](系统管理.assets/image-20201102174604022.png)
  - ![image-20201102174625051](系统管理.assets/image-20201102174625051.png)
  - ![image-20201102174633269](系统管理.assets/image-20201102174633269.png)

#### F1.1：【system-domain】DictType

#### F1.2：【system-domain】DictTypeDto

- 介绍

  - 在页面中进行查询时，往往不一定会查询对应表的所有字段；同样对数据进行添加的时候，也不一定是全部字段都进行添加，有些字段数据库会自动生成
  - 因此设置一个==数据传输==实体类来做交互（DataTransferObject）

- 添加

  ~~~JAVA
  package com.fclever.dto;
  
  import com.baomidou.mybatisplus.annotation.IdType;
  import com.baomidou.mybatisplus.annotation.TableField;
  import com.baomidou.mybatisplus.annotation.TableId;
  import io.swagger.annotations.ApiModel;
  import io.swagger.annotations.ApiModelProperty;
  import lombok.AllArgsConstructor;
  import lombok.Data;
  import lombok.EqualsAndHashCode;
  import lombok.NoArgsConstructor;
  
  import javax.validation.constraints.NotNull;
  import java.util.Date;
  
  /**
   * 数据传输类DataTransferObject
   *      查询和添加时不一定操作全部的
   * @author Fclever
   * @create 2020-11-02 20:21
   */
  @ApiModel(value="com-fclever-dto-DictTypeDto")
  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @EqualsAndHashCode(callSuper = false)
  public class DictTypeDto extends BaseDto{
  
      /**
       * 字典主键
       */
      @ApiModelProperty(value="字典主键")
      private Long dictId;
  
      /**
       * 字典名称
       */
      @NotNull(message = "字典名称不能为空")
      @ApiModelProperty(value="字典名称")
      private String dictName;
  
      /**
       * 字典类型
       */
      @NotNull(message = "字典类型不能为空")
      @ApiModelProperty(value="字典类型")
      private String dictType;
  
      /**
       * 状态（0正常 1停用）
       */
      @NotNull(message = "状态不能为空")
      @ApiModelProperty(value="状态（0正常 1停用）")
      private String status;
  
      /**
       * 创建者
       */
      @ApiModelProperty(value="创建者")
      private String createBy;
  
      /**
       * 创建时间
       */
      @ApiModelProperty(value="创建时间")
      private Date createTime;
  
      /**
       * 更新者
       */
      @ApiModelProperty(value="更新者")
      private String updateBy;
  
      /**
       * 更新时间
       */
      @ApiModelProperty(value="更新时间")
      private Date updateTime;
  
      /**
       * 备注
       */
      @ApiModelProperty(value="备注")
      private String remark;
  }
  
  ~~~

  

#### F1.3：【hospital-commons】DataGridView

- 做分页查询时，一般都需要返回总条数和实际查询的数据，在BaseDto中已经封装了页码|每页条数等，在commons再创建一个DataGridView来保存总条数和查询数据

- 添加

  ~~~java
  package com.fclever.vo;
  
  import io.swagger.annotations.ApiModel;
  import lombok.AllArgsConstructor;
  import lombok.Data;
  import lombok.NoArgsConstructor;
  
  import java.io.Serializable;
  import java.util.List;
  
  /**
   * 分页查询封装类
   *      总条数+实际数据
   * @author Fclever
   * @create 2020-11-02 20:32
   */
  @ApiModel(value="com-fclever-vo-DataGridView")
  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  public class DataGridView implements Serializable {
  
      // 查询总条数
      private Long total;
      // 查询到的数据
      private List<?> data;
  }
  
  ~~~

  

#### F1.4：【system-mapper】DictTypeMapper

#### F1.5：【system-mapper】DictTypeMapper.xml

#### F1.6：【system-interface】DictTypeService

~~~java
package com.fclever.service;

import com.fclever.domain.DictType;
import com.baomidou.mybatisplus.extension.service.IService;
import com.fclever.dto.DictTypeDto;
import com.fclever.vo.DataGridView;

/**
@author Fclever
@create 2020-11-02 17:47
*/
public interface DictTypeService{

        /**
         * 分页查询字典类型
         *
         * @param dictTypeDto 查询添加使用的封装类
         * @return 分页查询封装类
         */
        DataGridView listPage(DictTypeDto dictTypeDto);

        /**
         * 查询所有字典类型
         *
         * @return 分页查询封装类
         */
        DataGridView list();

        /**
         * 检查字典类型是否存在
         *
         * @param dictId 字典类型主键id
         * @param dictType  字典类型
         * @return 是否存在的标志
         */
        Boolean checkDictTypeUnique(Long dictId, String dictType);

        /**
         * 插入新的字典类型
         *
         * @param dictTypeDto 查询添加使用的封装类
         * @return 是否插入成功标志
         */
        int insert(DictTypeDto dictTypeDto);

        /**
         * 修改的字典类型 
         *
         * @param dictTypeDto 待修改的内容
         * @return 是否修改成功标志
         */
        int update(DictTypeDto dictTypeDto);

        /**
         * 根据ID删除字典类型
         *
         * @param dictIds 待批量删除的字典类型主键
         * @return 是否删除成功的标志
         */
        int deleteDictTypeByIds(Long[] dictIds);

        /**
         * 根据ID查询一个字典类型
         *
         * @param dictId 待查询的字典类型id
         * @return 查询到的字典类型
         */
        DictType selectDictTypeById(Long dictId);
}

~~~

#### F1.7：【system-service】DictTypeServiceImpl

~~~java
package com.fclever.service.impl;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.date.DateUtil;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.fclever.constants.Constants;
import com.fclever.dto.DictTypeDto;
import com.fclever.vo.DataGridView;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.fclever.mapper.DictTypeMapper;
import com.fclever.domain.DictType;
import com.fclever.service.DictTypeService;

import java.util.Arrays;
import java.util.List;

/**
@author Fclever
@create 2020-11-02 17:47
*/
@Service
public class DictTypeServiceImpl implements DictTypeService{

    @Autowired
    private DictTypeMapper dictTypeMapper;

    /**
     * 分页查询字典类型
     * @param dictTypeDto 查询添加使用的封装类
     * @return
     */
    @Override
    public DataGridView listPage(DictTypeDto dictTypeDto) {
        // Mybatisplus   设置分页默认值，默认为第一页，条数为10
        Page<DictType> page = new Page<>(dictTypeDto.getPageNum(), dictTypeDto.getPageSize());
        // 封装查询条件
        QueryWrapper<DictType> qw = new QueryWrapper<>();
        // 先判断是否字典名称是否为空，如果不为空，则将val作为对应表字段进行模糊like查询
        qw.like(StringUtils.isNotBlank(dictTypeDto.getDictName()), DictType.COL_DICT_NAME, dictTypeDto.getDictName());
        qw.like(StringUtils.isNotBlank(dictTypeDto.getDictType()), DictType.COL_DICT_TYPE, dictTypeDto.getDictType());
        // 等于匹配，非空后，做精确匹配
        qw.eq(StringUtils.isNotBlank(dictTypeDto.getStatus()), DictType.COL_STATUS, dictTypeDto.getStatus());
        // 范围匹配，创建日期（开始时间----结束时间）
        // 大于等于
        qw.ge(dictTypeDto.getBeginTime() != null, DictType.COL_CREATE_TIME, dictTypeDto.getBeginTime());
        // 小于等于
        qw.le(dictTypeDto.getEndTime() != null, DictType.COL_CREATE_TIME, dictTypeDto.getEndTime());
        // 根据pw查询，并将数据保存到page中
        // 调用Mapper执行selectPage(分页查询），条件为qw，保存分页相关信息和查询数据到page中
        this.dictTypeMapper.selectPage(page, qw);
        // 构建分页查询的封装类   数据总条数+查询到的数据
        return new DataGridView(page.getTotal(),page.getRecords());
    }

    /**
     * 查询所有字典类型    处于可用状态的字典类型
     * @return 分页查询封装类
     */
    @Override
    public DataGridView list() {
        QueryWrapper<DictType> qw = new QueryWrapper<>();
        // 查询条件，状态为0，可用的状态
        qw.eq(DictType.COL_STATUS, Constants.STATUS_TRUE);
        return new DataGridView(null, this.dictTypeMapper.selectList(qw));
    }

    /**
     * 检查字典类型是否存在
     *      比如在添加或者修改等操作时，需要验证该字典类型是否存在，这时候就会调用
     *      添加操作时，dictId为空，
     *      修改操作时，需要注意修改后的
     * @param dictId 字典类型主键id
     * @param dictType  字典类型
     * @return 是否存在的标志
     */
    @Override
    public Boolean checkDictTypeUnique(Long dictId, String dictType) {
        // 如果dictId为null，表示为增加操作，那么给它一个-1，数据库id自增， 所以不会出现相同，否则为更新操作
        dictId = (dictId == null) ? -1L : dictId;
        // 查询条件：查询字典类型等于选择的字典类型
        QueryWrapper<DictType> qw = new QueryWrapper<>();
        qw.eq(DictType.COL_DICT_TYPE, dictType);
        // 执行查询
        DictType dbDictType = this.dictTypeMapper.selectOne(qw);
        /**
         * 如果是添加操作，默认id为null，因为通过数据库自动递增，如果根据待添加的类型能在数据库查到数据
         *      就说明该种字典类型已经存在了，不需要重复添加，返回false，停止该操作
         *
         *  如果是更新操作，默认id为对应记录的id，根据类型能查询到结果，并且id相同，就返回true，可以进行更新操作
          */
        // 如果能根据字典类型查询到一条结果，并且查询到的id不相等，那就说明数据库不存在
        if (null != dbDictType && dictId.longValue() != dbDictType.getDictId().longValue()){
            return true; // 说明不存在
        }
        return false; // 说明存在
    }

    /**
     * 插入新的字典类型
     * @param dictTypeDto 查询添加使用的封装类
     * @return 是否插入成功的标志
     */
    @Override
    public int insert(DictTypeDto dictTypeDto) {
        // 形参为数据传输实体类，但是调用Mapper进行持久化需要使用原本实体类
        DictType dictType = new DictType();
        // 两个实体属性对应，将值进行拷贝  使用hutools工具类
        BeanUtil.copyProperties(dictTypeDto, dictType);
        dictType.setCreateBy(dictTypeDto.getSimpleUser().getUserName());
        dictType.setCreateTime(DateUtil.date());
        return this.dictTypeMapper.insert(dictType);
    }

    /**
     * 修改字典类型
     * @param dictTypeDto 待修改的内容
     * @return 是否修改成功的标志
     */
    @Override
    public int update(DictTypeDto dictTypeDto) {
        // 形参为数据传输实体类，但是调用Mapper进行持久化需要使用原本实体类
        DictType dictType = new DictType();
        // 设置修改人
        BeanUtil.copyProperties(dictTypeDto, dictType);
        dictType.setUpdateBy(dictTypeDto.getSimpleUser().getUserName());
        return this.dictTypeMapper.updateById(dictType);
    }

    /**
     * 根据ID删除字典类型
     * @param dictIds 待批量删除的字典类型主键
     * @return 是否删除成功的标志
     */
    @Override
    public int deleteDictTypeByIds(Long[] dictIds) {
        // 数组转集合
        List<Long> ids = Arrays.asList(dictIds);
        // 如果不为空，并且长度大于0，调用Mapper进行批量删除
        if (null != ids && ids.size() > 0){
            return this.dictTypeMapper.deleteBatchIds(ids);
        }
        return -1;
    }

    /**
     * 根据ID查询一个字典类型
     * @param dictId 待查询的字典类型id
     * @return 查询到的字典类型
     */
    @Override
    public DictType selectDictTypeById(Long dictId) {
        return this.dictTypeMapper.selectById(dictId);
    }
}

~~~



### F2：【system-web】编写接口公共的ShiroSecurityUtils

- 在进行系统管理模块中的操作时，有时会使用到当前登录用户的信息，如用户名啥的，编写一个工具类来获取登录用户信息

- 代代码码

  ~~~java
  package com.fclever.utils;
  
  import com.fclever.constants.Constants;
  import com.fclever.domain.SimpleUser;
  import com.fclever.domain.User;
  import com.fclever.vo.ActiverUser;
  import org.apache.shiro.SecurityUtils;
  import org.apache.shiro.subject.Subject;
  
  import java.util.List;
  
  /**
   * 获取当前登录用户相关信息
   * @author Fclever
   * @create 2020-11-03 12:30
   */
  public class ShiroSecurityUtils {
  
      /**
       * 得到当前登陆的用户对象的ActiveUser（包括用户基本信息+角色+权限）
       *      存储在Redis中
       * @return
       */
      public static ActiverUser getCurrentActiveUser(){
          Subject subject= SecurityUtils.getSubject();
          ActiverUser activerUser= (ActiverUser) subject.getPrincipal();
          return activerUser;
      }
  
      /**
       * 得到当前登陆的用户对象User
       * @return
       */
      public static User getCurrentUser(){
          return getCurrentActiveUser().getUser();
      }
  
      /**
       * 得到当前登陆的用户对象SimpleUser（用户id+用户姓名）
       * @return
       */
      public static SimpleUser getCurrentSimpleUser(){
          User user = getCurrentActiveUser().getUser();
          return new SimpleUser(user.getUserId(),user.getUserName());
      }
  
      /**
       * 得到当前登陆的用户名称
       * @return
       */
      public static String getCurrentUserName(){
          return getCurrentActiveUser().getUser().getUserName();
      }
  
      /**
       * 得到当前登陆对象的角色编码
       * @return
       */
      public static List<String> getCurrentUserRoles(){
          return getCurrentActiveUser().getRoles();
      }
  
  
      /**
       * 得到当前登陆对象的权限编码
       * @return
       */
      public static List<String> getCurrentUserPermissions(){
          return getCurrentActiveUser().getPermissions();
      }
  
      /**
       * 判断当前用户是否是超级管理员
       * @return
       */
      public static boolean isAdmin(){
          return getCurrentUser().getUserType().equals(Constants.USER_ADMIN);
      }
  }
  
  ~~~

  

### F3：【system-web】编写接口DictTypeController

- 代码

  ~~~java
  package com.fclever.controller.system;
  
  import com.fclever.dto.DictTypeDto;
  import com.fclever.service.DictTypeService;
  import com.fclever.utils.ShiroSecurityUtils;
  import com.fclever.vo.AjaxResult;
  import com.fclever.vo.DataGridView;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.validation.annotation.Validated;
  import org.springframework.web.bind.annotation.*;
  
  import javax.validation.constraints.NotEmpty;
  import javax.validation.constraints.NotNull;
  
  /**
   * 字典类型控制器
   * @author Fclever
   * @create 2020-11-03 14:35
   */
  @RestController
  @RequestMapping("system/dict/type")
  public class DictTypeController {
  
      @Autowired
      private DictTypeService dictTypeService;
  
      /**
       * 分页查询
       * @param dictTypeDto 分页查询参数
       * @return 消息+code+数据+total
       */
      @GetMapping("listForPage")
      public AjaxResult listForPage(DictTypeDto dictTypeDto){
          DataGridView dataGridView = this.dictTypeService.listPage(dictTypeDto);
          return AjaxResult.success("分页查询成功", dataGridView.getData(), dataGridView.getTotal());
      }
  
      /**
       * 添加字典类型
       * @param dictTypeDto 待添加字典类型
       * @return 消息+code
       */
      @PostMapping("addDictType")
      public AjaxResult addDictType(@Validated DictTypeDto dictTypeDto){
          // 检查数据库中是否已经存在了待添加的字典类型数据
          // 返回true表示可以存在，不能操作
          if (dictTypeService.checkDictTypeUnique(dictTypeDto.getDictId(), dictTypeDto.getDictType())){
              return AjaxResult.fail("新增字典["+dictTypeDto.getDictName()+"]失败，字典类型已经存在");
          }
          // 设置登录用户信息
          dictTypeDto.setSimpleUser(ShiroSecurityUtils.getCurrentSimpleUser());
          // 执行插入操作
          return AjaxResult.toAjax(this.dictTypeService.insert(dictTypeDto));
      }
  
      /**
       * 修改字典类型
       * @param dictTypeDto 待修改的数据
       * @return 消息+code
       */
      @PutMapping("updateDictType")
      public AjaxResult updateDictType(@Validated DictTypeDto dictTypeDto){
          // 检查数据库中是否已经存在了待修改的字典类型数据
          // 返回true表示可以存在，不能操作
          if (dictTypeService.checkDictTypeUnique(dictTypeDto.getDictId(), dictTypeDto.getDictType())){
              return AjaxResult.fail("修改字典["+dictTypeDto.getDictName()+"]失败，字典类型已经存在");
          }
          // 设置登录用户信息
          dictTypeDto.setSimpleUser(ShiroSecurityUtils.getCurrentSimpleUser());
          // 执行插入操作
          return AjaxResult.toAjax(this.dictTypeService.update(dictTypeDto));
      }
  
      /**
       * 根据id查询一个字典类型数据
       * @param dictId 字典类型主键id
       * @return 消息+code+数据
       */
      @GetMapping("getOne/{dictId}")
      public AjaxResult getOne(@PathVariable @Validated @NotNull(message = "字典主键ID不能为空")Long dictId){
          return AjaxResult.success(this.dictTypeService.selectDictTypeById(dictId));
      }
  
      /**
       * 根据id批量删除字典类型
       * @param dictIds 待批量删除的id
       * @return 消息+code
       */
      @DeleteMapping("deleteDictTypeByIds/{dictIds}")
      public AjaxResult deleteDictTypeByIds(@PathVariable @Validated @NotEmpty(message = "删除Id不能为空")Long[] dictIds){
          // 大于0，就表示成功
          return AjaxResult.toAjax(this.dictTypeService.deleteDictTypeByIds(dictIds));
      }
  
      /**
       * 查询所有状态可用的字典类型
       * @return 消息+code+数据+总条数
       */
      @GetMapping("selectAllDictType")
      public AjaxResult selectAllDictType(){
          return AjaxResult.success(this.dictTypeService.list());
      }
  }
  
  ~~~

  

### F4：YApi接口测试

- 需要先登录一下，拿到token
- 测试都没有问题

### F5：验证异常处理

- 在添加字典的时候，如果什么参数都不传递，发送请求时，会因为@Validated注解而报错，因为DictTypeDto类中属性上添加了非空校验

  - ![image-20201103175143676](系统管理.assets/image-20201103175143676.png)
  - ![image-20201103175159532](系统管理.assets/image-20201103175159532.png)
  - ![image-20201103175339883](系统管理.assets/image-20201103175339883.png)

- 从控制台中可以看到，因为校验出错报的信息就是BindException异常

- 添加BindException异常处理方法

  - 代码

    ~~~java
    package com.fclever.config.exception;
    
    import com.fclever.vo.AjaxResult;
    import org.springframework.validation.BindException;
    import org.springframework.validation.BindingResult;
    import org.springframework.validation.FieldError;
    import org.springframework.validation.ObjectError;
    import org.springframework.web.bind.MethodArgumentNotValidException;
    import org.springframework.web.bind.annotation.ExceptionHandler;
    import org.springframework.web.bind.annotation.RestControllerAdvice;
    
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    
    
    /**
     * 全局异常处理
     * @author Fclever
     * @create 2020-10-27 13:54
     */
    @RestControllerAdvice // Rest会以JSON的形式返回数据
    public class GlobalExceptionHandler {
    
        /**
         * 方法参数无效异常---如果页面传参是json对象，当json对象为空时能触发
         * 当系统出现MethodArgumentNotValidException这个异常时，会调用下面的方法
         * @param e
         * @return
         */
        @ExceptionHandler(value = MethodArgumentNotValidException.class)
        public AjaxResult jsonErrorHandler(MethodArgumentNotValidException e){
            return getAjaxResult(e.getBindingResult());
        }
    
        /**
         *
         * 当系统出现BindException这个异常时，会调用下面的方法
         * @param e
         * @return
         */
        @ExceptionHandler(value = BindException.class)
        public AjaxResult jsonErrorHandler(BindException e){
            return getAjaxResult(e.getBindingResult());
        }
    
        /**
         * 抽取公共模块
         * @param bindingResult
         * @return
         */
        private AjaxResult getAjaxResult(BindingResult bindingResult) {
            List<Map<String, Object>> list = new ArrayList<>();
            List<ObjectError> allErrors = bindingResult.getAllErrors();
            for (ObjectError allError : allErrors) {
                Map<String, Object> map = new HashMap<>();
                map.put("defaultMessage", allError.getDefaultMessage());
                map.put("objectName", allError.getObjectName());
                // 转换类型，获取属性 FieldError extends ObjectError
                // field属性需要从FieldError获取
                FieldError fieldError = (FieldError) allError;
                map.put("field", fieldError.getField());
                list.add(map);
            }
            return AjaxResult.fail("后端数据校验异常", list);
        }
    }
    
    ~~~

    

  - ![image-20201103190120790](系统管理.assets/image-20201103190120790.png)

## 前端

# 字典数据管理

## 后端

### F1：生成字典数据相关代码

- ![image-20201103200750268](系统管理.assets/image-20201103200750268.png)
- ![image-20201103200957488](系统管理.assets/image-20201103200957488.png)
- ![image-20201103201017328](系统管理.assets/image-20201103201017328.png)

#### F1.1：【system-domain】DictData

#### F1.2：【system-domain】DictDataDto

~~~java
package com.fclever.dto;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import javax.validation.constraints.NotNull;
import java.util.Date;

/**
 * 字典数据数据传输类
 * @author Fclever
 * @create 2020-11-03 20:35
 */
@ApiModel(value="com-fclever-domain-DictData")
@Data
@EqualsAndHashCode(callSuper=true)
@AllArgsConstructor
@NoArgsConstructor
public class DictDataDto extends BaseDto{

    /**
     * 字典编码
     */
    @ApiModelProperty(value="字典编码")
    private Long dictCode;

    /**
     * 字典排序
     */
    @ApiModelProperty(value="字典排序")
    @NotNull(message = "字典排序不能为空")
    private Integer dictSort;

    /**
     * 字典标签
     */
    @ApiModelProperty(value="字典标签")
    @NotNull(message = "字典标签不能为空")
    private String dictLabel;

    /**
     * 字典键值
     */
    @ApiModelProperty(value="字典键值")
    @NotNull(message = "字典键值不能为空")
    private String dictValue;

    /**
     * 字典类型
     */
    @ApiModelProperty(value="字典类型")
    @NotNull(message = "字典类型不能为空")
    private String dictType;

    /**
     * 状态（0正常 1停用）
     */
    @ApiModelProperty(value="状态（0正常 1停用）")
    @NotNull(message = "状态不能为空")
    private String status;

    /**
     * 备注
     */
    @ApiModelProperty(value="备注")
    private String remark;

    /**
     * 创建者
     */
    @ApiModelProperty(value="创建者")
    private String createBy;

    /**
     * 创建时间
     */
    @ApiModelProperty(value="创建时间")
    private Date createTime;

    /**
     * 更新者
     */
    @ApiModelProperty(value="更新者")
    private String updateBy;

    /**
     * 更新时间
     */
    @ApiModelProperty(value="更新时间")
    private Date updateTime;
}

~~~



#### F1.3：【system-mapper】DictDataMapper

#### F1.4：【system-mapper】DictDataMapper.xml

#### F1.5：【system-interface】DictDataService

~~~java
package com.fclever.service;

import com.fclever.domain.DictData;
import com.baomidou.mybatisplus.extension.service.IService;
import com.fclever.dto.DictDataDto;
import com.fclever.vo.DataGridView;

import java.util.List;

/**
@author Fclever
@create 2020-11-03 20:11
*/
public interface DictDataService{

    /**
     * 分页查询字典数据
     *
     * @param dictDataDto 查询条件
     * @return 分页查询封装对象  total+数据
     */
    DataGridView listPage(DictDataDto dictDataDto);


    /**
     * 插入新的字典数据
     *
     * @param dictDataDto 待插入数据
     * @return 插入成功的标志
     */
    int insert(DictDataDto dictDataDto);

    /**
     * 修改字典数据
     *
     * @param dictDataDto 待修改数据
     * @return  修改成功的标志
     */
    int update(DictDataDto dictDataDto);

    /**
     * 根据ID删除字典数据
     *
     * @param dictCodeIds 待删除的数据集合
     * @return 删除成功的标志
     */
    int deleteDictDataByIds(Long[] dictCodeIds);

    /**
     * 根据字典类型查询字典数据
     *
     * @param dictType 待查询的字典类型
     * @return 查询到的字典数据集合
     */
    List<DictData> selectDictDataByDictType(String dictType);

    /**
     * 根据ID查询一个字典数据
     *
     * @param dictCode 字典数据主键
     * @return 查询到的字典数据
     */
    DictData selectDictDataById(Long dictCode);
}

~~~



#### F1.6：【system-service】DictDataServiceImpl

~~~java
package com.fclever.service.impl;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.json.JSON;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.fclever.constants.Constants;
import com.fclever.dto.DictDataDto;
import com.fclever.vo.DataGridView;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;
import java.util.Arrays;
import java.util.List;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.fclever.domain.DictData;
import com.fclever.mapper.DictDataMapper;
import com.fclever.service.DictDataService;
/**
@author Fclever
@create 2020-11-03 20:11
*/
@Service
public class DictDataServiceImpl implements DictDataService{

    @Autowired
    private DictDataMapper dictDataMapper;

    /**
     * 分页查询字典数据
     * @param dictDataDto 查询条件
     * @return 封装的查询条件
     */
    @Override
    public DataGridView listPage(DictDataDto dictDataDto) {
        // 分页  默认第一页，每页10条记录
        Page<DictData> page=new Page<>(dictDataDto.getPageNum(),dictDataDto.getPageSize());
        // 拼接查询参数
        QueryWrapper<DictData> qw=new QueryWrapper<>();
        // 字典类型相等（页面中字典名称）
        qw.eq(StringUtils.isNotBlank(dictDataDto.getDictType()),DictData.COL_DICT_TYPE,dictDataDto.getDictType());
        // 字典标签模糊查询
        qw.like(StringUtils.isNotBlank(dictDataDto.getDictLabel()),DictData.COL_DICT_LABEL,dictDataDto.getDictLabel());
        // 字典数据状态精确匹配
        qw.eq(StringUtils.isNotBlank(dictDataDto.getStatus()),DictData.COL_STATUS,dictDataDto.getStatus());
        // 执行查询，查询后数据存放于page中
        this.dictDataMapper.selectPage(page,qw);
        // 封装分页数据
        return new DataGridView(page.getTotal(),page.getRecords());
    }

    /**
     * 插入新的字典数据
     *
     * @param dictDataDto 待插入数据
     * @return 插入成功的标志
     */
    @Override
    public int insert(DictDataDto dictDataDto) {
        // 持久化实体对象
        DictData dictData=new DictData();
        // 拷贝数据   源--》目标
        BeanUtil.copyProperties(dictDataDto,dictData);
        //设置创建者名称，创建时间
        dictData.setCreateBy(dictDataDto.getSimpleUser().getUserName());
        dictData.setCreateTime(DateUtil.date());
        // 执行插入操作
        return this.dictDataMapper.insert(dictData);
    }

    /**
     * 根据id修改字典数据
     *
     * @param dictDataDto 待修改数据
     * @return  修改成功的标志
     */
    @Override
    public int update(DictDataDto dictDataDto) {
        // 持久化实体对象
        DictData dictData=new DictData();
        // 拷贝属性  源--》目标
        BeanUtil.copyProperties(dictDataDto,dictData);
        //设置修改人名称
        dictData.setUpdateBy(dictDataDto.getSimpleUser().getUserName());
        // 根据id执行修改操作
        return this.dictDataMapper.updateById(dictData);
    }

    /**
     * 根据ID删除字典数据
     *
     * @param dictCodeIds 待删除的字典数据主键
     * @return 删除成功的标志
     */
    @Override
    public int deleteDictDataByIds(Long[] dictCodeIds) {
        // 数组转化为集合
        List<Long> ids= Arrays.asList(dictCodeIds);
        // 判断不为空并且长度大于0
        if(null != ids && ids.size() > 0){
            // 根据字典id批量删除字典数据
            return this.dictDataMapper.deleteBatchIds(ids);
        }else{
            // 返回-1，表示id为空
            return -1;
        }
    }

    /**
     * 根据字典类型查询字典数据
     *
     * @param dictType 待查询的字典类型
     * @return 查询到的字典数据集合
     */
    @Override
    public List<DictData> selectDictDataByDictType(String dictType) {
        QueryWrapper<DictData> qw = new QueryWrapper<>();
        // 既然根据类型去查，类型肯定不为空
        qw.eq(DictData.COL_DICT_TYPE, dictType);
        // 设置排序
        qw.orderByAsc(DictData.COL_DICT_SORT);
        // 有效  数据
        qw.eq(DictData.COL_STATUS, Constants.STATUS_TRUE);
        return this.dictDataMapper.selectList(qw);
    }

    /**
     * 根据ID查询一个字典数据
     *
     * @param dictCode 字典数据主键
     * @return 查询到的字典数据
     */
    @Override
    public DictData selectDictDataById(Long dictCode) {
        return this.dictDataMapper.selectById(dictCode);
    }
}

~~~



### F2：【system-web】DictDataController

~~~java
package com.fclever.controller.system;

import com.fclever.domain.DictData;
import com.fclever.dto.DictDataDto;
import com.fclever.service.DictDataService;
import com.fclever.utils.ShiroSecurityUtils;
import com.fclever.vo.AjaxResult;
import com.fclever.vo.DataGridView;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import java.util.List;

/**
 * 字典数据控制器
 * @author Fclever
 * @create 2020-11-04 08:46
 */
@RestController
@RequestMapping("system/dict/data")
public class DictDataController {

    @Autowired
    private DictDataService dictDataService;

    /**
     * 分页查询
     * @param dictDataDto 分页查询参数
     * @return 消息+code+数据+total
     */
    @GetMapping("listForPage")
    public AjaxResult listForPage(DictDataDto dictDataDto){
        DataGridView dataGridView = this.dictDataService.listPage(dictDataDto);
        return AjaxResult.success("分页查询成功", dataGridView.getData(), dataGridView.getTotal());
    }

    /**
     * 添加字典数据
     * @param dictDataDto 待添加字典数据
     * @return 消息+code
     */
    @PostMapping("addDictData")
    public AjaxResult addDictData(@Validated DictDataDto dictDataDto){
        // 设置登录用户信息
        dictDataDto.setSimpleUser(ShiroSecurityUtils.getCurrentSimpleUser());
        // 执行插入操作
        return AjaxResult.toAjax(this.dictDataService.insert(dictDataDto));
    }

    /**
     * 修改字典数据
     * @param dictDataDto 待修改的字典数据
     * @return 消息+code
     */
    @PutMapping("updateDictData")
    public AjaxResult updateDictData(@Validated DictDataDto dictDataDto){
        // 设置登录用户信息
        dictDataDto.setSimpleUser(ShiroSecurityUtils.getCurrentSimpleUser());
        // 执行插入操作
        return AjaxResult.toAjax(this.dictDataService.update(dictDataDto));
    }

    /**
     * 根据id查询一个字典数据
     * @param dictCode 字典主键id
     * @return 消息+code+数据
     */
    @GetMapping("getOne/{dictCode}")
    public AjaxResult getOne(@PathVariable @Validated @NotBlank(message = "字典数据主键ID不能为空")Long dictCode){
        return AjaxResult.success(this.dictDataService.selectDictDataById(dictCode));
    }

    /**
     * 根据id批量删除字典数据
     * @param dictCodeIds 待批量删除的id
     * @return 消息+code
     */
    @DeleteMapping("deleteDictDataByIds/{dictCodeIds}")
    public AjaxResult deleteDictDataByIds(@PathVariable @Validated @NotBlank(message = "删除Id不能为空")Long[] dictCodeIds){
        // 大于0，就表示成功
        return AjaxResult.toAjax(this.dictDataService.deleteDictDataByIds(dictCodeIds));
    }

    /**
     * 根据字典类型查询字典数据
     *
     * @param dictType 待查询的字典类型
     * @return 查询到的字典数据集合
     */
    @GetMapping("getDataByType/{dictType}")
    public AjaxResult getDataByType(@PathVariable @Validated @NotNull(message = "字典类型不能为空") String dictType){
        List<DictData> dictDataList = this.dictDataService.selectDictDataByDictType(dictType);
        return AjaxResult.success("根据字典类型查询数据成功", dictDataList);
    }
}

~~~



### F3：YApi测试

- 测试通过

## 前端

# 字典缓存处理

- 数据字典在其他系统管理其他菜单下也会经常用到，比如状态啥的，之前的方式都是通过DictDataServiceImpl中的selectDictDataByDictTypeMapper方法来从数据库根据字典类型来进行查询，对数据库操作很频繁
- 让其他菜单模块的使用的字典数据从缓存中查询，可以在字典管理中，增设一个《同步缓存》按钮，把最新的字典数据更新到缓存中，然后点击后其他菜单模块的内容就是最新的了

## 后端

### F1：【hospital-system】修改pom.xml（添加内容）

~~~xml
<!--redis依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
~~~



### F2：【system-web】修改DictTypeController

~~~java
/**
     * 同步字典数据到缓存（包括字典类型+对应类型数据），如果缓存原来有内容，则直接覆盖
     * @return
             */
    @GetMapping("dictCacheAsync")
    public AjaxResult dictCacheAsync(){
        try{
            this.dictTypeService.dictCacheAsync();
            return AjaxResult.success();
        }catch (Exception e){
            e.printStackTrace();
            // 出现异常则返回错误信息
            return AjaxResult.error();
        }
    }
~~~



### F3：【system-interface】修改DictTypeService

~~~java
/**
         * 同步字典类型数据+字典数据到缓存，其他菜单模块查询字典数据直接从缓存获取
         */
        void dictCacheAsync();
~~~



### F4：【hospital-commons】修改Constant

~~~java
/**
     * redis的字典前缀
     */
    public static final String DICT_REDIS_PROFIX="dict:";
~~~



### F5：【system-service】修改DictTypeServiceImpl

~~~java
/**
     * 同步字典类型数据+字典数据到缓存，其他菜单模块查询字典数据直接从缓存获取
     * 1. 先查询出所有可用的字典数据
     * 2. 再根据字典的类型查询对应类型的字典数据
     * 3. 把整个字典数据生成json，保存到redis中
     * 保存到Redis中key的形式
     *  dict:dictType
     * 保存到Redis中value形式
     *  对应字典类型的所有字典数据的数组，数组内容单条数据为一条对象
     * 实际形式：dict:sys_user_sex   --->  [{},{},{}]
     *
     */
    @Override
    public void dictCacheAsync() {
        // 封装查询结果
        QueryWrapper<DictType> qwType = new QueryWrapper<>();
        // 状态为可用
        qwType.eq(DictType.COL_STATUS, Constants.STATUS_TRUE);
        // 执行查询保存结果
        List<DictType> dictTypeList = this.dictTypeMapper.selectList(qwType);
        for (DictType dictType : dictTypeList) {
            // 根据字典类型查询对应的字典数据
            QueryWrapper<DictData> qwData = new QueryWrapper<>();
            // 类型匹配
            qwData.eq(DictData.COL_DICT_TYPE, dictType.getDictType());
            // 并且为可用状态的字典数据
            qwData.eq(DictData.COL_STATUS, dictType.getStatus());
            qwData.orderByAsc(DictData.COL_DICT_SORT);
            // 执行查询，并接收List集合
            List<DictData> dictDataList = dictDataMapper.selectList(qwData);
            // 转成json
            String json = JSON.toJSONString(dictDataList);
            // 保存内容(Reids保存格式）
            ValueOperations<String, String> opsForValue = redisTemplate.opsForValue();
            opsForValue.set(Constants.DICT_REDIS_PROFIX+dictType.getDictType(), json);

        }
    }
~~~



### F6：【system-service】修改DictDataServiceImpl

~~~java
/**
     * 根据字典类型查询字典数据
     *
     * @param dictType 待查询的字典类型
     * @return 查询到的字典数据集合
     */
    @Override
    public List<DictData> selectDictDataByDictType(String dictType) {
        // 之前是从数据库里面根据字典类型来获取对应的字典数据，现在在字典类型实现类中进行了缓存同步，就直接根据key从缓存中获取就可以了
//        QueryWrapper<DictData> qw = new QueryWrapper<>();
//        // 既然根据类型去查，类型肯定不为空
//        qw.eq(DictData.COL_DICT_TYPE, dictType);
//        // 设置排序
//        qw.orderByAsc(DictData.COL_DICT_SORT);
//        // 有效  数据
//        qw.eq(DictData.COL_STATUS, Constants.STATUS_TRUE);
//        return this.dictDataMapper.selectList(qw);
        // 设置从Redis中获取的前缀
        String key = Constants.DICT_REDIS_PROFIX + dictType;
        ValueOperations<String, String> opsForValue = redisTemplate.opsForValue();
        // 根据key获取json值对象
        String json = opsForValue.get(key);
        // 将JSON对象转换为数组对象，根据DictData实体类进行解析
        List<DictData> dictDataList = JSON.parseArray(json, DictData.class);
        return dictDataList;
    }
~~~



### F7：YApi测试

- 使用RedisDesktopManager工具测试
  - 192.168.125.20:6390   root
  - ![image-20201104162845402](系统管理.assets/image-20201104162845402.png)

## 前端

# 操作日志管理

后端

前端

# 登录日志管理

后端

前端

# 科室管理

后端

前端

# 菜单管理

后端

前端

# 角色管理

后端

前端

# 用户管理

后端

前端

# 通知公告管理

后端

前端

# 检查项目管理

后端

前端

# 挂号费用管理

后端

前端