<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.fclever.mapper.MenuMapper">
  <resultMap id="BaseResultMap" type="com.fclever.domain.Menu">
    <!--@mbg.generated-->
    <!--@Table sys_menu-->
    <id column="menu_id" jdbcType="BIGINT" property="menuId" />
    <result column="parent_id" jdbcType="BIGINT" property="parentId" />
    <result column="parent_ids" jdbcType="VARCHAR" property="parentIds" />
    <result column="menu_name" jdbcType="VARCHAR" property="menuName" />
    <result column="menu_type" jdbcType="CHAR" property="menuType" />
    <result column="percode" jdbcType="VARCHAR" property="percode" />
    <result column="path" jdbcType="VARCHAR" property="path" />
    <result column="remark" jdbcType="VARCHAR" property="remark" />
    <result column="status" jdbcType="CHAR" property="status" />
    <result column="create_time" jdbcType="TIMESTAMP" property="createTime" />
    <result column="update_time" jdbcType="TIMESTAMP" property="updateTime" />
    <result column="create_by" jdbcType="VARCHAR" property="createBy" />
    <result column="update_by" jdbcType="VARCHAR" property="updateBy" />
  </resultMap>
  <sql id="Base_Column_List">
    <!--@mbg.generated-->
    menu_id, parent_id, parent_ids, menu_name, menu_type, percode, `path`, remark, `status`, 
    create_time, update_time, create_by, update_by
  </sql>

  <!--根据菜单id查询它子节点的个数-->
  <select id="queryChildCountByMenuId" resultType="java.lang.Long">
    select count(1) from sys_menu where parent_id = #{menuId}
  </select>

  <!--根据角色id查询该角色已经分配的所有菜单id(仅仅查询子菜单id  not in就是用来排除是父菜单id的条件）-->
  <!--
    select rmone.menu_id from sys_role_menu rmone
    where rmone.role_id = #{roleId}
          可以查询到角色-菜单关联表中，要查询的角色id已经分配的菜单id
          但是这样的查询结果中含有父菜单id，如果按这种形式返回到前台，那么会导致某个父菜单下明明仅仅选择了非全部子菜单，
          但是显示为全部勾选
    and rm.menu_id not in
    (
        select m.parent_id from sys_menu m
        inner join sys_role_menu rmtwo
        on m.menu_id = rmtwo.menu_id and rmtwo.role_id = #{roleId}
    )
          这里进行进一步过滤，联合菜单表和角色-菜单关联表，查找出两表中menu_id相同的记录
          并且筛选出这些记录中在关联表中的角色id为查询的角色id，这样的话，就可以查询出所有和外层select同样的结果
          但是最终是通过菜单表，找到以上数据的父菜单id，只要外层查询结果的菜单id不再这些父菜单id之内，就表示为子菜单id
    以下两个SQL查询结果是一样的
          select rmone.menu_id from sys_role_menu rmone
          where rmone.role_id = #{roleId}

          select m.menu_id from sys_menu m
          inner join sys_role_menu rmtwo
          on m.menu_id = rmtwo.menu_id and rmtwo.role_id = #{roleId}
    括号内的作用+and rm.menu_id not in  就是为了把父菜单排除掉，因为只要返回子菜单，前端就可以自动判断父菜单是全选还是半选
  -->
  <select id="queryMenuIdsByRoleId" resultType="java.lang.Long">
    select rmone.menu_id from sys_role_menu rmone
    where rmone.role_id = #{roleId} and rmone.menu_id not in
    (
        select distinct(m.parent_id) from sys_menu m
        inner join sys_role_menu rmtwo
        on m.menu_id = rmtwo.menu_id and rmtwo.role_id = #{roleId}
    )
  </select>
  <!--根据用户Id查询用户所拥有的菜单 一个用户有多个角色，多个角色中的菜单可能有重复，distinct会去除重复的菜单-->
  <select id="selectMenuListByUserId" resultMap="BaseResultMap">
    select distinct t1.* from sys_menu t1 inner join sys_role_menu t2 inner join sys_role_user t3
    on (t1.menu_id = t2.menu_id and t2.role_id = t3.role_id)
    where t3.user_id = #{userId}
  </select>
</mapper>